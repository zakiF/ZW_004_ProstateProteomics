---
title: "DE analysis"
date: "2025-06-25"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: true
    toc_depth: 3
    number_sections: false
    theme: lumen
---

# Background

We bridged the different batches using limma. Now we want to run DE to find cohort specific proteins.

# Objectives

1. DE analysis
2. Heatmap viz


# Conclusion

We used a cut-off of 0.2 FDR and 1.4 log fold change and identified **overexpresed** stage specific DEPs.  

# Pre-processing 

## Loading packages

```{r, message=FALSE, warning=FALSE}
library(here)
library(tidyverse)
library(readxl)   
library(readr)
library(stringr)
library(ggplot2)
library(paletteer)
library(VennDiagram)
library(ggvenn)
library(ggbeeswarm)
# DE
library(limma)
# Survival
library(survival)
library(ggsurvfit)
library(survminer)
# Heatmap
library(ComplexHeatmap)
library(circlize)
```

## Directories

```{r}
wd <- list()
wd$main <- here()
wd$data <- file.path(wd$main, "data")
wd$manishData <- file.path(wd$data, "raw/data_fromManish")
wd$d2024 <- file.path(wd$data, "updated_2024")
wd$d2024_npx <- file.path(wd$d2024, "NPX_data")
wd$output <- file.path(wd$main, "output")
wd$script <- file.path(wd$main, "scripts")

wd$outData <- file.path(wd$output, "data")
wd$outCurr <- file.path(wd$output, "03_Bridge_DE")
```


Create directories

```{r}
if (!file.exists(wd$outCurr)) {
  dir.create(wd$outCurr)
} else {
  print("Directory already exists")
}
```

Load functions

```{r}
source(file.path(wd$script, "functions.R"))
```

## Load data

Load the processed metadata file

```{r}
# TO DO - load the saved R object
load(file.path(wd$outData, "01_Metadata.Rdata"))
load(file.path(wd$outData, "02_data.Rdata"))
```

### Load other files

List of cell surface markers, Olink flex panel...etc

```{r}
# List of cell surface markers
cs <- read.delim(file.path(wd$outData, "CS_human.txt"))

# Olink FLEX proteins
df_flex <- read.csv(file.path(wd$data, "Olink Flex - 2025-04-08.csv"), sep = ";")
```

We also have genes that are druggable from DrugBank https://go.drugbank.com/releases/latest#protein-identifiers

```{r}
# Downloaded the file from DrugBank
df_target <- read.csv(file.path(wd$data, "DrugBank/drugbank_all_target_polypeptide_ids.csv/all.csv"))
df_vocab <- read.csv(file.path(wd$data, "DrugBank/drugbank vocabulary.csv"))
```

## Other variables

Specify the cut-off for DE

```{r}
cut_logFC <- 0.4 # Log FC cut-off
cut_bfc <- 2^cut_logFC # Base fold change cut-off (Around 1.3 if the log2FC os 0.4)
cut_fdr <- 0.2 
```

# Obj 1: DE

Use the linear model approach. Note we will run DE on Pre- and Post- treated samples

```{r}
# -----------------------
# 1) Generate to gene x sample matrix
# -----------------------
mat_all <- exprMatrix_corrected_sub

# --------------------------------
# 2) Create design and contrasts
# --------------------------------
# Groups for each of the columns
df_group <- df_meta_f5 %>% select(HCI_cID, sample_id_psom, sample_id_Q13356, sample_id_Q15806, txt_stat_ordered) %>% 
  mutate(id1 = paste0("Disc_", sample_id_psom),
         id2 = paste0("Proj2_", sample_id_Q13356),
         id3 = paste0("Proj4_", sample_id_Q15806)
         ) #%>% 
  # Select earliest Pre- treatment
  #filter(txt_stat_ordered %in% c("Pre1"))
df_group <- data.frame(
  HCI_cID = df_group$HCI_cID,
  sampleID = c(df_group$id1, df_group$id2, df_group$id3)
) %>% 
  filter(!str_detect(sampleID, 'NA')) %>% 
  filter(sampleID %in% colnames(mat_all))

# Data frame for design matrix
df_de_anno <- df_group %>% left_join(df_meta_f5) %>% 
  filter(sampleID %in% colnames(mat_all)) 

exp_mat_sub <- mat_all[,df_de_anno$sampleID]

identical(colnames(exp_mat_sub), df_de_anno$sampleID)

group <- df_de_anno$cohort

# Model matrix with no intercept (i.e., "0 + group" form)
design <- model.matrix(~ 0 + group)
colnames(design) <- c("A", "B", "C_D")

# Create two contrasts: A_vs_CD and B_vs_CD
# +ve fold change will be the one on the left
contrast.matrix <- makeContrasts(
  A_vs_CD = C_D - A,
  B_vs_CD = C_D - B,
  A_vs_B = B - A,
  levels   = design
)


# ------------------------------------------------------------
# 3) Fit linear model, apply contrasts, and get unfiltered topTable
# ------------------------------------------------------------
fit  <- lmFit(exp_mat_sub, design)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)

# Collect all results (no filtering) in a single data frame:
results_df <- data.frame()

for(i in seq_len(ncol(contrast.matrix))) {
  # Extract all genes (number=Inf), no sorting by p-value
  tt <- topTable(fit2, coef = i, number = Inf, sort.by = "none")
  
  # Add columns for clarity
  tt$Gene     <- rownames(tt)
  tt$Contrast <- colnames(contrast.matrix)[i]
  
  # Combine
  results_df <- rbind(results_df, tt)
}

# Print the final results data frame (unfiltered)
limma_df <- results_df %>% 
  rename(OlinkID = Gene) %>% 
  left_join(df_id_pro) %>% 
  rename(Adjusted_pval = adj.P.Val,
         log2FC = logFC) %>% 
  # For table purpose keep it clean (round the number)
  mutate(log2FC = round(log2FC, 2),
         P.Value = as.numeric(sprintf("%.1e", P.Value)),
         Adjusted_pval = as.numeric(sprintf("%.1e", Adjusted_pval)))
write.csv(limma_df, file.path(wd$outCurr, "DE_genes_limma.csv"))
```

Interpretation of log2FC based on the design matrix ;

- For A_vs_CD, log2FC < 0 means higher in A (up in A), log2FC > 0 means higher in CD (up in CD).
- For B_vs_CD, log2FC < 0 means higher in B (up in B), log2FC > 0 means higher in CD (up in CD).
- For A_vs_B, log2FC < 0 means higher in A (up in A), log2FC > 0 means higher in B (up in B).


## MA plot

Just have a look at some of the MA plots

```{r MA-plot, fig.width=12, fig.height=4}
# MA plot for all contrasts in limma_df
# A is usually the average log2 expression (AveExpr)
# M is log2FC

ggplot(limma_df, aes(x = AveExpr, y = log2FC)) +
  geom_point(aes(color = Adjusted_pval < cut_fdr), alpha = 0.6, size = 1) +
  scale_color_manual(values = c("grey", "red"), labels = c("NS", "FDR < 0.2")) +
  geom_hline(yintercept = c(-cut_logFC, cut_logFC), linetype = "dashed", color = "blue") +
  facet_wrap(~Contrast, nrow = 1) +
  labs(
    title = "MA Plots for All Contrasts",
    x = "Average Expression (AveExpr)",
    y = "log2 Fold Change (M)",
    color = "Significant"
  ) +
  theme_bw()
```

## Overlap upregulated

Get overlap

```{r}
# Protein specific to A
df_cat_a <- limma_df %>%
  #filter(Cat %in% c("c_b_vs_a", "c_cd_vs_a") & Adjusted_pval <= cut_fdr)
  filter(Contrast %in% c("A_vs_B", "A_vs_CD") & Adjusted_pval <= cut_fdr & log2FC <= -cut_logFC)

df_cat_b_1 <- limma_df %>%
  filter(Contrast %in% c("B_vs_CD") & Adjusted_pval <= cut_fdr & log2FC <= -cut_logFC)
df_cat_b_2 <- limma_df %>%
  filter(Contrast %in% c("A_vs_B") & Adjusted_pval <= cut_fdr & log2FC >= cut_logFC)

df_cat_b <- rbind(df_cat_b_1, df_cat_b_2)

df_cat_cd <- limma_df %>%
  #filter(Cat %in% c("c_a_vs_cd", "c_b_vs_cd") & Adjusted_pval <= cut_fdr)
  filter(Contrast %in% c("A_vs_CD", "B_vs_CD") & Adjusted_pval <= cut_fdr & log2FC >= cut_logFC)


un_a <- unique(df_cat_a$OlinkID)
un_b <- unique(df_cat_b$OlinkID)
un_cd <- unique(df_cat_cd$OlinkID)


overlap <- calculate.overlap(
x <- list("Group A"=un_a, 
          "Group B"=un_b,
          "Group CD"=un_cd))

ggvenn(
  x, 
  fill_color = pal.cohort.n2,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)

pdf(file=file.path(wd$outCurr, "DE_venn_overlap_Limma_up.pdf"), width = 5, height = 5)
ggvenn(
  x, 
  fill_color = pal.cohort.n2,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)
dev.off()

# Protein defining cd stage only
cd_prot <- overlap$a7
```

Save the output

```{r}
# Combine all lists into a single data frame
all_elements <- unique(c(un_a, un_b, un_cd)) # All unique elements

# Apply the function across all elements
overlap_degree <- sapply(all_elements, function(x) get_overlap_degree(x, list("Group A" = un_a, "Group B" = un_b, "Group CD" = un_cd)))

# Create final data frame
overlap_df_limma <- data.frame(
  OlinkID = all_elements,
  OverlapDegree = overlap_degree
) %>% left_join(df_id_pro)

write.csv(overlap_df_limma, file.path(wd$outCurr, "DE_genes_limma_up.csv"))
```

### Example protein

```{r}
# NOTE - if want to find the over expressed proteins in one of the category, the category group of interest should be at the back. Eg - c_b_vs_cd" means we are interested in looking at over-expressed proteins in "cd" group compared to "b". 

# ll <- limma_df %>% filter(Cat == "c_b_vs_cd") %>% pull(OlinkID) %>% head()

# xxx <- df_de_bridge %>% filter(Cat == "c_b_vs_cd") %>% 
#   dplyr::arrange(desc(log2FC))

df_npx_long <- exp_mat_sub %>%
  as.data.frame() %>% 
  tibble::rownames_to_column(var = "OlinkID") %>% 
  pivot_longer(cols = -OlinkID, names_to = "final_sample_id", values_to = "NPX")

df_plot <- df_npx_long %>% 
  left_join(df_id_pro) %>% 
  dplyr::filter(Assay %in% c("KLK4")) %>% 
  left_join(df_final_ids %>% select(final_sample_id, cohort))

# Show the plot
max_y <- max(df_plot$NPX)
min_y <- min(df_plot$NPX)

p_viol_gene <- 
  df_plot %>%
  ggplot(aes(x = cohort, y = NPX, fill = cohort)) +
  geom_quasirandom(dodge.width=0.9, colour="grey30", alpha=0.5) +
  geom_violin(alpha = 0.5, scale = "width", position = position_dodge(width = 0.9)) +
  geom_boxplot(outlier.alpha = 0,  width = 0.2, coef=0,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(values=unique(pal.cohort)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_line(linetype = "blank"), 
        panel.grid.minor = element_line(linetype = "blank"),
        axis.text.x = element_text(angle = 0)) +
  facet_wrap(~Assay, ncol=6, scales = "free_y") +
  geom_signif(
    comparisons = list(c("A", "B"),
                       c("B", "C"),
                       c("A", "C")),
    map_signif_level = FALSE,
    test = "t.test",
    y_position = c(max_y, max_y+1, max_y+2)
  ) +
  scale_y_continuous(limits=c(min_y, max_y+3)) +
  NULL
p_viol_gene
```


## Overlap dwn

Get overlap

```{r}
# Proteins downregulated in each group
# Downregulated in A: up in CD vs A (A_vs_CD, log2FC > cut_logFC)
df_cat_a_dwn <- limma_df %>%
  filter(
    Contrast %in% c("A_vs_CD", "A_vs_B"),
    Adjusted_pval <= cut_fdr,
    log2FC > cut_logFC
  )

# Downregulated in B: up in CD vs B (B_vs_CD, log2FC > cut_logFC) and up in A vs B (A_vs_B, log2FC < -cut_logFC)
df_cat_b_1_dwn <- limma_df %>%
  filter(Contrast == "B_vs_CD", Adjusted_pval <= cut_fdr, log2FC > cut_logFC)
df_cat_b_2_dwn <- limma_df %>%
  filter(Contrast == "A_vs_B", Adjusted_pval <= cut_fdr, log2FC < -cut_logFC)
df_cat_b_dwn <- rbind(df_cat_b_1_dwn, df_cat_b_2_dwn)

# Downregulated in CD: up in A vs CD (A_vs_CD, log2FC < -cut_logFC) and up in B vs CD (B_vs_CD, log2FC < -cut_logFC)
df_cat_cd_dwn <- limma_df %>%
  filter(Contrast %in% c("A_vs_CD", "B_vs_CD"), Adjusted_pval <= cut_fdr, log2FC < -cut_logFC)

un_a_dwn <- unique(df_cat_a_dwn$OlinkID)
un_b_dwn <- unique(df_cat_b_dwn$OlinkID)
un_cd_dwn <- unique(df_cat_cd_dwn$OlinkID)

overlap_dwn <- calculate.overlap(
  x <- list("Group A"=un_a_dwn, 
            "Group B"=un_b_dwn,
            "Group CD"=un_cd_dwn))

ggvenn(
  x, 
  fill_color = pal.cohort.n2,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)

pdf(file=file.path(wd$outCurr, "DE_venn_overlap_Limma_downregulated.pdf"), width = 5, height = 5)
ggvenn(
  x, 
  fill_color = pal.cohort.n2,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)
dev.off()

# Protein defining CD stage only (downregulated in CD)
cd_prot_dwn <- overlap_dwn$a7
```

Save the output

```{r}
# Combine all lists into a single data frame
all_elements <- unique(c(un_a_dwn, un_b_dwn, un_cd_dwn)) # All unique elements

# Apply the function across all elements
overlap_degree <- sapply(all_elements, function(x) get_overlap_degree(x, list("Group A" = un_a_dwn, "Group B" = un_b_dwn, "Group CD" = un_cd_dwn)))

# Create final data frame
overlap_df_limma_dwn <- data.frame(
  OlinkID = all_elements,
  OverlapDegree = overlap_degree
) %>% left_join(df_id_pro)

write.csv(overlap_df_limma_dwn, file.path(wd$outCurr, "DE_genes_limma_downregulated.csv"))
```


# Obj 2: Heatmap Viz

Lets visualize the proteins in the venn diagram.

Begin with a basic heatmap representation.

I want the order to be

```{r}
order_proteins <- c("Group A", "Group A and Group B",
                    "Group B", "Group B and Group CD",
                    "Group CD")
```


## Basic

Heatmap based on overlap_df_limma proteins using exp_mat_sub

```{r heatmap-overlap-exp_mat_sub, fig.width=10, fig.height=6}
# Subset exp_mat_sub to only proteins in overlap_df_limma
mat_overlap <- exp_mat_sub[intersect(overlap_df_limma$OlinkID, rownames(exp_mat_sub)), ]

# Scale rows (z-score)
pheatmap.scale <- function(x) {
  m = apply(x, 1, mean, na.rm = T)
  s = apply(x, 1, sd, na.rm = T)
  return((x - m) / s)
}
heatmap_data_overlap <- pheatmap.scale(mat_overlap)

# Example column groups
df_colname <- data.frame(
  SampleID = colnames(heatmap_data_overlap)) %>% 
  left_join(df_meta_f5 %>% rename(SampleID = final_sample_id))

# group_colors <- c("A" = "#1f77b4", 
#                   "B" = "#ff7f0e",
#                   "C_D" = "#2ca02c")  


group_colors <- c("A" = "#AEC7E8", 
                  "B" = "#FFBB78",
                  "C" = "#98DF8A")  


# Add metadata (reuse df_meta_id and df_colname from previous code)

# Create column annotation
column_anno_overlap <- HeatmapAnnotation(
  Group = df_colname$cohort,
  col = list(Group = group_colors),
  annotation_legend_param = list(
    title = "Column Groups",
    at = names(group_colors),
    labels = names(group_colors)
  )
)

# Define the heatmap
ht_overlap <- Heatmap(
  heatmap_data_overlap,
  name = "Expression",
  row_title = "Genes (overlap)",
  column_title = "Samples",
  top_annotation = column_anno_overlap,
  show_row_names = FALSE,
  show_column_names = FALSE,
  cluster_rows = FALSE
)

# Draw the heatmap
pdf(file.path(wd$outCurr, "Heatmap_overlap_df_limma.pdf"), height = 6, width = 10)
draw(ht_overlap, heatmap_legend_side = "right", annotation_legend_side = "right")
dev.off()
```

## Version 1

Make heatmap better ordered

```{r}
# Use the overlap-based heatmap data
# Cluster A samples
sample_A <- df_colname %>% filter(cohort == "A")
mat_tmp <-  heatmap_data_overlap[,sample_A$SampleID]

p_heat <- 
  pheatmap::pheatmap(mat_tmp, 
                     cluster_rows = TRUE, 
                     cluster_cols = TRUE,
                     scale = "none", # Change to none if we scaled the data
                     silent = TRUE)
a_or <- sample_A$SampleID[p_heat$tree_col$order]

# Just get the mean / median of all genes and order by it
column_medians_a <- sort(apply(mat_tmp, 2, function(x) median(x, na.rm = TRUE)))


# Use the overlap-based heatmap data
# Cluster B samples
sample_B <- df_colname %>% filter(cohort == "B")
mat_tmp <-  heatmap_data_overlap[,sample_B$SampleID]

p_heat <- 
  pheatmap::pheatmap(mat_tmp, 
                     cluster_rows = TRUE, 
                     cluster_cols = TRUE,
                     scale = "none", # Change to none if we scaled the data
                     silent = TRUE)
b_or <- sample_B$SampleID[p_heat$tree_col$order]

# Just get the mean / median of all genes and order by it
column_medians_b <- sort(apply(mat_tmp, 2, function(x) median(x, na.rm = TRUE)))


# Use the overlap-based heatmap data
# Cluster C samples
sample_CD <- df_colname %>% filter(cohort == "C")
mat_tmp <-  heatmap_data_overlap[,sample_CD$SampleID]

p_heat <- 
  pheatmap::pheatmap(mat_tmp, 
                     cluster_rows = TRUE, 
                     cluster_cols = TRUE,
                     scale = "none", # Change to none if we scaled the data
                     silent = TRUE)
cd_or <- sample_CD$SampleID[p_heat$tree_col$order]

# Just get the mean / median of all genes and order by it
column_medians <- sort(apply(mat_tmp, 2, function(x) median(x, na.rm = TRUE)))

# Re arrange the heatmap 
# Make cohort A first
o1 <- df_colname %>% filter(cohort == "A") %>% pull(SampleID)
# Cohort B 2nd
o2 <- df_colname %>% filter(cohort == "B") %>% pull(SampleID)

# Now order
mat22_or <- heatmap_data_overlap[,c(o1, o2, names(column_medians))]
mat22_or <- heatmap_data_overlap[,c(
  names(column_medians_a),
  o2,
  names(column_medians))]

# New order 
new_or <- data.frame(
  SampleID = c(o1, o2, cd_or)
) %>% left_join(df_colname)

# Add the txt_stats data as well 
# df_colname - Use this


# Create column annotation
column_anno2 <- HeatmapAnnotation(
  Group = new_or$cohort,
  #OS = new_or$OS,
  col = list(Group = group_colors),
  annotation_legend_param = list(
    title = "Column Groups",
    at = names(group_colors),
    labels = names(group_colors)
  )
)


# Generate a custom color scheme
paletteLength <- 30
mypalette1 <- rev(paletteer::paletteer_c('ggthemes::Red-Blue Diverging', paletteLength))
mypalette1 <- as.character(mypalette1)  # Ensure the colors are character strings

# Define breaks for the colors
myBreaks <- seq(-2, 3, length.out = paletteLength)  # Match the number of breaks to paletteLength

# Create a custom color function using colorRamp2
col_fun <- colorRamp2(myBreaks, mypalette1)


# --- Row annotation and ordering ---
order_proteins <- c("A", "A and B", "B", "B and CD", "CD")

# Map OverlapDegree to new labels (remove 'Group ')
overlap_df_limma$OverlapSimple <- gsub("Group ", "", overlap_df_limma$OverlapDegree)

# Add a category column to overlap_df_limma if not present
if (!"Category" %in% colnames(overlap_df_limma)) {
  overlap_df_limma$Category <- factor(overlap_df_limma$OverlapSimple, levels = order_proteins)
}

# Order overlap_df_limma by Category and OverlapDegree
row_annot_df <- overlap_df_limma %>%
  mutate(Category = factor(OverlapSimple, levels = order_proteins)) %>%
  arrange(Category, OverlapDegree)

# Subset to only those in the heatmap
row_annot_df <- row_annot_df[row_annot_df$OlinkID %in% rownames(mat22_or), ]

# Reorder mat22_or to match row_annot_df
mat22_or <- mat22_or[row_annot_df$OlinkID, ]

# Create row annotation with simplified labels
row_anno <- rowAnnotation(
  Overlap = row_annot_df$Category,
  col = list(Overlap = structure(RColorBrewer::brewer.pal(length(order_proteins), "Set1"), names = order_proteins)),
  annotation_legend_param = list(title = "Overlap Category")
)

# Calculate row gaps for group separators
gaps_row <- cumsum(as.numeric(table(row_annot_df$Category)))
if (length(gaps_row) > 0) {
  gaps_row <- gaps_row[-length(gaps_row)] # Remove last, no gap after last group
}

# Add txt_stat to column annotation
txt_stat_vec <- new_or$txt_stat
if (is.null(txt_stat_vec)) {
  txt_stat_vec <- df_colname$txt_stat[match(new_or$SampleID, df_colname$SampleID)]
}

# Define colors for txt_stat
txt_stat_colors <- c("Pre" = "grey90", "Post" = "black")  # Example colors, adjust as needed

column_anno2 <- HeatmapAnnotation(
  Group = new_or$cohort,
  txt_stat = txt_stat_vec,
  col = list(
    Group = group_colors,
    txt_stat = txt_stat_colors
  ),
  annotation_legend_param = list(
    Group = list(
      title = "Column Groups",
      at = names(group_colors),
      labels = names(group_colors)
    ),
    txt_stat = list(
      title = "txt_stat",
      at = names(txt_stat_colors),
      labels = names(txt_stat_colors)
    )
  )
)

# Calculate row gaps for group separators
gaps_row <- cumsum(as.numeric(table(row_annot_df$Category)))
if (length(gaps_row) > 0) {
  gaps_row <- gaps_row[-length(gaps_row)] # Remove last, no gap after last group
}

# Define the heatmap with row annotation and row separators
ht <- Heatmap(
  mat22_or,
  name = "Expression",
  row_title = "Genes",
  column_title = "Samples",
  top_annotation = column_anno2,
  left_annotation = row_anno,
  show_row_names = FALSE,
  show_column_names = FALSE,
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  column_split = factor((new_or$cohort)),  # Split columns by groups
  gap = unit(2, "mm"),  # Specify gap size between groups
  row_split = row_annot_df$Category,      # Split rows by group
  row_gap = unit(2, "mm"),                # Gap between row groups
  col = col_fun,  # Apply the custom color function
  heatmap_legend_param = list(
    #title = "Z-score",
    at = seq(-2, 3, by = 1),  # Adjust ticks to match your breaks
    labels = seq(-2, 3, by = 1)  # Labels for each tick
  )
)

# Combine heatmap and annotations
pdf(file.path(wd$outCurr, "Stage_specific_heatmap.pdf"), height = 6, width = 12)
draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
dev.off()
```

## Boxplot

Boxplot of expression for each gene group (order_proteins) across the three cohorts

```{r boxplot-gene-groups, fig.width=8, fig.height=5}
# Long format: each row = (protein, sample, NPX, group, cohort)
mat_long <- as.data.frame(mat22_or)
mat_long$OlinkID <- rownames(mat22_or)
mat_long$Group <- row_annot_df$Category
mat_long <- tidyr::pivot_longer(mat_long, -c(OlinkID, Group), names_to = "SampleID", values_to = "NPX")
mat_long <- dplyr::left_join(mat_long, new_or[,c("SampleID", "cohort")], by = "SampleID")

# Only keep A, B, C cohorts
mat_long <- mat_long %>% filter(cohort %in% c("A", "B", "C"))

# Plot
p <- ggplot(mat_long, aes(x = cohort, y = NPX, fill = cohort)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  #geom_jitter(width = 0.2, size = 0.5, alpha = 0.5) +
  facet_wrap(~ Group) +
  scale_fill_manual(values = group_colors) +
  scale_y_continuous(limits=c(-2.5,2.5)) +
  theme_bw() +
  labs(title = "Expression by Gene Group and Cohort",
       x = "Cohort",
       y = "NPX Expression") +
  theme_custom

print(p)
ggsave(p, file=file.path(wd$outCurr, "Median_NPX.pdf"), height = 5, width = 7)
```

# Save objects

```{r}
save(
  cut_logFC, cut_fdr,
  limma_df, cd_prot, overlap_df_limma, 
  cd_prot_dwn, overlap_df_limma_dwn, 
  file = file.path(wd$outData, "03_data.Rdata"))
```

