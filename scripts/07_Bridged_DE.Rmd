---
title: "Pronosis"
date: "2025-04-09"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

# Background

We bridged the different batches using limma. Now we want to run DE to find cohort specific proteins.

# Objectives

1. Perfom DE 
2. Perfom prognosis 



# Conclusion


# Pre-processing 

## Loading packages

```{r, message=FALSE, warning=FALSE}
library(here)
library(tidyverse)
library(readxl)   
library(readr)
library(stringr)
library(ggplot2)
library(paletteer)
library(VennDiagram)
library(ggvenn)
# DE
library(limma)
# Survival
library(survival)
library(ggsurvfit)
library(survminer)
```

## Directories

```{r}
wd <- list()
wd$main <- here()
wd$data <- file.path(wd$main, "data")
wd$manishData <- file.path(wd$data, "raw/data_fromManish")
wd$d2024 <- file.path(wd$data, "updated_2024")
wd$d2024_npx <- file.path(wd$d2024, "NPX_data")
wd$output <- file.path(wd$main, "output")
wd$script <- file.path(wd$main, "scripts")

wd$outData <- file.path(wd$output, "data")
wd$outCurr <- file.path(wd$output, "07_Bridge_DE")
```


Create directories

```{r}
if (!file.exists(wd$outCurr)) {
  dir.create(wd$outCurr)
} else {
  print("Directory already exists")
}
```

Load functions

```{r}
source(file.path(wd$script, "functions.R"))
```

## Load data

Load the processed metadata file

```{r}
# TO DO - load the saved R object
load(file.path(wd$outData, "01_Metadata.Rdata"))
load(file.path(wd$outData, "02_data.Rdata"))
load(file.path(wd$outData, "04_data.Rdata"))
load(file.path(wd$outData, "06_data.Rdata"))
```

### Load other files

List of cell surface markers, Olink flex panel...etc

```{r}
# List of cell surface markers
cs <- read.delim(file.path(wd$outData, "CS_human.txt"))

# Olink FLEX proteins
df_flex <- read.csv(file.path(wd$data, "Olink Flex - 2025-04-08.csv"), sep = ";")
```

We also have genes that are druggable from DrugBank https://go.drugbank.com/releases/latest#protein-identifiers

```{r}
# Downloaded the file from DrugBank
df_target <- read.csv(file.path(wd$data, "DrugBank/drugbank_all_target_polypeptide_ids.csv/all.csv"))
df_vocab <- read.csv(file.path(wd$data, "DrugBank/drugbank vocabulary.csv"))
```

# Obj 1: DE

Use the linear model approach. 

```{r}
# -----------------------
# 1) Generate to gene x sample matrix
# -----------------------
mat_all <- exprMatrix_corrected_sub

# --------------------------------
# 2) Create design and contrasts
# --------------------------------
# Groups for each of the columns
df_group <- df_meta_f %>% select(HCI_cID, sample_id_psom, sample_id_Q13356, sample_id_Q15806) %>% 
  mutate(id1 = paste0("Disc_", sample_id_psom),
         id2 = paste0("Proj2_", sample_id_Q13356),
         id3 = paste0("Proj4_", sample_id_Q15806)
         )
df_group <- data.frame(
  HCI_cID = df_group$HCI_cID,
  sampleID = c(df_group$id1, df_group$id2, df_group$id3)
) %>% filter(!str_detect(sampleID, 'NA'))

# Data frame for design matrix
df_de_anno <- df_meta_f %>% left_join(df_group) %>% 
  filter(sampleID %in% colnames(mat_all)) 

exp_mat_sub <- mat_all[,df_de_anno$sampleID]

identical(colnames(exp_mat_sub), df_de_anno$sampleID)

group <- df_de_anno$cohort

# Model matrix with no intercept (i.e., "0 + group" form)
design <- model.matrix(~ 0 + group)
colnames(design) <- c("A", "B", "C_D")

# Create two contrasts: A_vs_CD and B_vs_CD
# +ve fold change will be the one on the left
contrast.matrix <- makeContrasts(
  A_vs_CD = C_D - A,
  B_vs_CD = C_D - B,
  A_vs_B = B - A,
  levels   = design
)

# ------------------------------------------------------------
# 3) Fit linear model, apply contrasts, and get unfiltered topTable
# ------------------------------------------------------------
fit  <- lmFit(mat_all, design)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)

# Collect all results (no filtering) in a single data frame:
results_df <- data.frame()

for(i in seq_len(ncol(contrast.matrix))) {
  # Extract all genes (number=Inf), no sorting by p-value
  tt <- topTable(fit2, coef = i, number = Inf, sort.by = "none")
  
  # Add columns for clarity
  tt$Gene     <- rownames(tt)
  tt$Contrast <- colnames(contrast.matrix)[i]
  
  # Combine
  results_df <- rbind(results_df, tt)
}

# Print the final results data frame (unfiltered)
limma_df <- results_df %>% 
  rename(OlinkID = Gene) %>% 
  left_join(df_id_pro) %>% 
  rename(Adjusted_pval = adj.P.Val,
         log2FC = logFC)
```

## Overlap

Get overlap

```{r}
# Protein specific to A
df_cat_a <- limma_df %>%
  #filter(Cat %in% c("c_b_vs_a", "c_cd_vs_a") & Adjusted_pval <= cut_fdr)
  filter(Contrast %in% c("A_vs_B", "A_vs_CD") & Adjusted_pval <= cut_fdr & log2FC <= -cut_logFC)

df_cat_b_1 <- limma_df %>%
  filter(Contrast %in% c("B_vs_CD") & Adjusted_pval <= cut_fdr & log2FC <= -cut_logFC)
df_cat_b_2 <- limma_df %>%
  filter(Contrast %in% c("A_vs_B") & Adjusted_pval <= cut_fdr & log2FC >= cut_logFC)

df_cat_b <- rbind(df_cat_b_1, df_cat_b_2)

df_cat_cd <- limma_df %>%
  #filter(Cat %in% c("c_a_vs_cd", "c_b_vs_cd") & Adjusted_pval <= cut_fdr)
  filter(Contrast %in% c("A_vs_CD", "B_vs_CD") & Adjusted_pval <= cut_fdr & log2FC >= cut_logFC)


un_a <- unique(df_cat_a$OlinkID)
un_b <- unique(df_cat_b$OlinkID)
un_cd <- unique(df_cat_cd$OlinkID)


overlap <- calculate.overlap(
x <- list("Group A"=un_a, 
          "Group B"=un_b,
          "Group CD"=un_cd))

ggvenn(
  x, 
  fill_color = pal.cohort.n2,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)

pdf(file=file.path(wd$outCurr, "DE_venn_overlap_Limma.pdf"), width = 5, height = 5)
ggvenn(
  x, 
  fill_color = pal.cohort.n2,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)
dev.off()

# Protein defining cd stage only
cd_prot <- overlap$a7
```

Save the output

```{r}
# Combine all lists into a single data frame
all_elements <- unique(c(un_a, un_b, un_cd)) # All unique elements

# Apply the function across all elements
overlap_degree <- sapply(all_elements, function(x) get_overlap_degree(x, list("Group A" = un_a, "Group B" = un_b, "Group CD" = un_cd)))

# Create final data frame
overlap_df_limma <- data.frame(
  OlinkID = all_elements,
  OverlapDegree = overlap_degree
) %>% left_join(df_id_pro)

write.csv(overlap_df_limma, file.path(wd$outCurr, "DE_genes_limma.csv"))
```





# SKIPPED BEGIN

## DE table

> TO DO

Lets generate a table of the proteins to show their mean expression level, fold change and FDR.

```{r}
# Get the Mean expression in cohort A, B & C_D
tt <- df_de_bridge %>% select(OlinkID, Cat, Mean_Y, Mean_N) %>% 
  filter(OlinkID %in% overlap_df_limma$OlinkID)

# Step 1: Extract group1 and group2 from 'Cat'
df_clean <- tt %>%
  mutate(
    group1 = str_extract(Cat, "(?<=c_)[^_]+"),
    group2 = str_extract(Cat, "(?<=vs_).*")
  )

# Step 2: Reshape to long format, linking Mean_Y to group1 and Mean_N to group2
df_long <- df_clean %>%
  select(OlinkID, group1, group2, Mean_Y, Mean_N) %>%
  pivot_longer(cols = c(Mean_Y, Mean_N), names_to = "type", values_to = "mean_value") %>%
  mutate(group = if_else(type == "Mean_Y", group1, group2)) %>%
  select(OlinkID, group, mean_value) %>%
  distinct()  # keep unique (OlinkID, group, mean) pairs

# Step 3: Pivot to wide format
df_wide <- df_long %>%
  pivot_wider(names_from = group, values_from = mean_value)
```

For each of the Olink ID add the fold change, p-value and FDR as determined by limma

```{r}
# Step 1: pivot longer to put all numeric columns under one column with names
df2_long <- limma_df %>%
  filter(OlinkID %in% overlap_df_limma$OlinkID) %>% 
  select(OlinkID, Contrast, log2FC, t, P.Value, Adjusted_pval) %>% 
  pivot_longer(cols = c(log2FC, t, P.Value, Adjusted_pval),
               names_to = "metric", values_to = "value")

# Step 2: unite metric and contrast for column names
df2_wide <- df2_long %>%
  mutate(name = paste0(metric, "_", Contrast)) %>%
  select(-metric, -Contrast) %>%
  pivot_wider(names_from = name, values_from = value)
```

Join both of them with the overlap data

```{r}
overlap_df_limma_full <- overlap_df_limma %>% 
  left_join(df_wide) %>% 
  left_join(df2_wide) %>% 
  arrange(OverlapDegree, Assay)

write.csv(overlap_df_limma_full, file.path(wd$outCurr, "DE_genes_limma_with_pVal.csv"))
```




## Breakdown

Since the comparison is to get the proteins overexpressed in CD state, it can be from comparing A vs CD or B vs CD. Lets get the counts based on the category

```{r}
pivot_table <- limma_df %>% 
  filter(Contrast %in% c("A_vs_CD", "B_vs_CD")) %>% 
  filter (Adjusted_pval  <= cut_fdr & log2FC >= cut_logFC) %>% 
  filter(OlinkID %in% overlap$a7) %>% 
  select(OlinkID, Assay, Contrast) %>% 
  mutate(present = 1) %>%  # Add a column to indicate presence
  pivot_wider(names_from = Contrast, values_from = present, values_fill = list(present = 0))

summary_cat <- pivot_table %>%
  mutate(category = case_when(
    A_vs_CD == 1 & B_vs_CD == 0 ~ "A_vs_CD only",
    A_vs_CD == 0 & B_vs_CD == 1 ~ "B_vs_CD only",
    A_vs_CD == 1 & B_vs_CD == 1 ~ "Both A_vs_CD and B_vs_CD",
    TRUE ~ "Other"
  ))
summary_counts <- summary_cat %>% count(category)
```


We shot the plot of the top proteins

```{r}
tt <- limma_df %>% 
  filter(Contrast %in% c("A_vs_CD", "B_vs_CD")) %>% 
  filter (Adjusted_pval  <= cut_fdr & log2FC >= cut_logFC) %>% 
  filter(OlinkID %in% overlap$a7)

t1 <- summary_cat %>% filter(category == "A_vs_CD only")
top_a <- tt %>% filter(OlinkID %in% t1$OlinkID) %>% 
  slice_max(log2FC, n=1, with_ties = FALSE)
#slice_min(Adjusted_pval, n=1, with_ties = FALSE)

t1 <- summary_cat %>% filter(category == "B_vs_CD only")
top_b <- tt %>% filter(OlinkID %in% t1$OlinkID) %>% 
  slice_max(log2FC, n=10, with_ties = FALSE)
#slice_min(Adjusted_pval, n=1, with_ties = FALSE)

t1 <- summary_cat %>% filter(category == "Both A_vs_CD and B_vs_CD")
top_both <- tt %>% filter(OlinkID %in% t1$OlinkID) %>% 
  slice_max(log2FC, n=1, with_ties = FALSE)
#slice_min(Adjusted_pval, n=1, with_ties = FALSE)

# Generate the plot 
top_pro <- c(top_a$OlinkID, top_b$OlinkID[6], top_both$OlinkID)
top_ass <- c(top_a$Assay, top_b$Assay[6], top_both$Assay)
df_plot <- dat_NPX %>%
  dplyr::filter(OlinkID %in% top_pro) %>%
  mutate(Assay = factor(Assay, levels = (top_ass)))

# Show the plot
max_y <- max(df_plot$NPX)
min_y <- min(df_plot$NPX)

p_viol_gene <- 
  df_plot %>%
  ggplot(aes(x = cohort, y = NPX, fill = cohort)) +
  geom_quasirandom(dodge.width=0.1, width = 0.3, colour="grey30", alpha=0.5) +
  geom_violin(alpha = 0.5, scale = "width", width=0.7, position = position_dodge(width = 0.9)) +
  geom_boxplot(outlier.alpha = 0,  width = 0.2, coef=0,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(values=unique(pal.cohort.n2)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_line(linetype = "blank"), 
        panel.grid.minor = element_line(linetype = "blank"),
        axis.text.x = element_text(angle = 0)) +
  facet_wrap(~Assay, ncol=1, scales = "free_y") +
  #scale_y_continuous(limits=c(min_y, max_y+3)) +
  NULL
p_viol_gene

# Save plot
ggsave(p_viol_gene, file=file.path(wd$outCurr, "mCRPC_violin_categroies.pdf"), height = 7, width = 5)
```


Rather than a single gene, we can do a trend plot for all the genes

```{r}
tt <- limma_df %>% 
  filter(Contrast %in% c("A_vs_CD", "B_vs_CD")) %>% 
  filter (Adjusted_pval  <= cut_fdr & log2FC >= cut_logFC) %>% 
  filter(OlinkID %in% overlap$a7)

t1 <- summary_cat %>% filter(category == "A_vs_CD only")
top_a <- tt %>% filter(OlinkID %in% t1$OlinkID) 

t1 <- summary_cat %>% filter(category == "B_vs_CD only")
top_b <- tt %>% filter(OlinkID %in% t1$OlinkID) 

t1 <- summary_cat %>% filter(category == "Both A_vs_CD and B_vs_CD")
top_both <- tt %>% filter(OlinkID %in% t1$OlinkID)

```

Now generate some plots

```{r}
# Plot a z-normlized 
df_plot <- dat_NPX %>%
  dplyr::filter(OlinkID %in% top_pro) %>%
  mutate(Assay = factor(Assay, levels = (top_ass)))

# Show the plot
max_y <- max(df_plot$NPX)
min_y <- min(df_plot$NPX)

p_viol_gene <- 
  df_plot %>%
  ggplot(aes(x = cohort, y = NPX, fill = cohort)) +
  geom_quasirandom(dodge.width=0.1, width = 0.3, colour="grey30", alpha=0.5) +
  geom_violin(alpha = 0.5, scale = "width", width=0.7, position = position_dodge(width = 0.9)) +
  geom_boxplot(outlier.alpha = 0,  width = 0.2, coef=0,
               position = position_dodge(width = 0.9)) +
  scale_fill_manual(values=unique(pal.cohort.n2)) +
  theme_bw() +
  theme(legend.position = "none",
        panel.grid.major = element_line(linetype = "blank"), 
        panel.grid.minor = element_line(linetype = "blank"),
        axis.text.x = element_text(angle = 0)) +
  facet_wrap(~Assay, ncol=1, scales = "free_y") +
  #scale_y_continuous(limits=c(min_y, max_y+3)) +
  NULL
p_viol_gene
```

## Cluster proteins

Another way to classify this is simply identify which are higher in category A vs B. 

```{r}
tt2 <- limma_df %>% 
  filter(Contrast %in% c("A_vs_B")) %>% 
  filter(OlinkID %in% tt$OlinkID) %>% 
  arrange(desc(log2FC))
summary(tt2$log2FC)
```

Identify proteins that are higher in A compared to B 

```{r}
high_a <- tt2 %>% filter(log2FC < 0)
high_b <- tt2 %>% filter(log2FC >= 0)
```

Lets plot these

```{r}
df_high <- data.frame(
  OlinkID = c(high_a$OlinkID, high_b$OlinkID),
  category = c(rep("High_A", each=nrow(high_a)),
               rep("High_B", each=nrow(high_b)))
) %>% left_join(df_id_pro)

# Merge with NPX dataset to keep only relevant OlinkIDs
merged_data <- dat_NPX %>%
  dplyr::select(OlinkID, NPX, cohort) %>% 
  inner_join(df_high, by = "OlinkID")

# Z-score normalization per OlinkID
scaled_data <- merged_data %>%
  group_by(OlinkID) %>%
  mutate(scaled_NPX = scale(NPX)) %>%
  ungroup()

# Summarize mean NPX per cohort & contrast
summary_data <- scaled_data %>%
  group_by(category, cohort) %>%
  summarise(mean_scaled_NPX = mean(scaled_NPX), .groups = "drop")

ggplot(summary_data, aes(x = cohort, y = mean_scaled_NPX, group = category, colour = cohort)) +
  geom_point(size = 5) +  # Points
  scale_colour_manual(values=pal.cohort.n2) +
  geom_line(aes(group = category), color = "black", linetype = "dashed") +  # Connect points
  facet_wrap(~ category, scales = "free_y", nrow=2) +  # Facet by contrast
  theme_minimal() +
  labs(x = "Cohort", y = "Mean Scaled NPX Expression", title = "Expression Patterns Across Cohorts") +
  theme_custom +
  NULL


ggsave(file=file.path(wd$outCurr, "GenePatterns.pdf"), height = 5, width = 6)
```

# SKIPPED END

# Obj 2: Prognosis

We perform multivariate analysis on the patients. We want to see if the proteins that are over-expressed in the discovery cohort are associated with prognosis. 

Its best if we limit our analysis to the proteins over-expressed in mCRPC

```{r}
length(cd_prot)
```

We need to trim down the protein to those that were detected

```{r}
cd_prot_sub <- cd_prot[cd_prot %in% rownames(exprMatrix_corrected_sub)]  # <------
# # Manish mentioned CD34, it is currently tested in clicnial trials
# id1 <- df_id_pro %>% filter(Assay == "CD34") %>% pull(OlinkID)
# cd_prot_sub <- c(cd_prot_sub, id1)
# CD34 gave HR to 0.8 - non significant
```

For these proteins run a cox proportional analysis. 

## Clinical data

Lets re-set the clinical data. Because Enos provided an updated annotation

```{r}
# 1st file has all the HCI_id
dd <- read_xlsx(file.path(wd$d2024, "clinical_data/Demographics Patients_Proteomics 4-14-25 1.xlsx"),
sheet = 2)
df_clin1 <- data.frame(
  mrn = dd$`MRN (UUHSC)`,
  HCI_cID = c(dd$Sample1_HCI_Num, dd$Sample2_HCI_Num, dd$Sample3_HCI_Num),
  collection_date = c(dd$Sample1_date, dd$`Sample 2 Start date`, dd$`Sample3_Start date`),
  psa = c(dd$sample1_psa, dd$sample2_psa, dd$sample3_psa),
  ldh = c(dd$sample1_ldh, dd$sample2_ldh, dd$sample3_ldh),
  alk_ph = c(dd$sample1_alk_phos, dd$sample2_alk_phos, dd$sample3_alk_phos)
  ) %>% 
  mutate(psa = gsub("<", "", psa),
         psa = as.numeric(psa),
         ldh = as.numeric(ldh),
         alk_ph = as.numeric(alk_ph)) %>% 
  filter(!is.na(HCI_cID))

# 2nd file has the corrected diagnosis dates, biochem date and mcrpc_txt date

#censor_date <- "2025-05-02"
censor_date <- as.Date('2024-11-14') # November 14, 2024
dd <- read_xlsx(file.path(wd$d2024, "clinical_data/Proteomic study (Zaki) excel file_2025_05_02.xlsx"),
sheet = 3)
df_clin2 <- data.frame(
  mrn = dd$`MRN (UUHSC)`,
  biochem_date = dd$biochem_crpc_date,
  mcrpc_tx_date = dd$`1st_mcrpc_rx_date`,
  death_date = dd$`Death date`,
  death = dd$`Deceased?`,
  diag_date = dd$`Diagnosis date`
  ) 

df_clin <- df_clin1 %>% left_join(df_clin2)

# Censor the date
df_clin$death_date[is.na(df_clin$death_date)] <- censor_date

# Calulate OS in months 
# Time to event is defined as ;
# As per conversation with Manish, we will take the earliest date between ;
# biochem or mcrpc_txt_date. If no dates are available take the sample collection
# Creatre a column to indicate this
df_clin <- df_clin %>%
  mutate(
    # Get the earliest of biochem and mcrpc_tx
    earliest_tx_date = pmin(biochem_date, mcrpc_tx_date, na.rm = TRUE),
    
    # Use collection_date if both are NA
    final_date = if_else(is.na(earliest_tx_date), collection_date, earliest_tx_date),
    
    # Indicator of source
    date_source = case_when(
      !is.na(earliest_tx_date) & earliest_tx_date == biochem_date ~ "biochem",
      !is.na(earliest_tx_date) & earliest_tx_date == mcrpc_tx_date ~ "mcrpc_tx",
      TRUE ~ "collection"
    )
  )

# Calculate OS
df_clin <- df_clin %>% 
  mutate(OS = as.numeric(difftime(death_date, final_date, units = "days")),
         OS = round(OS/30.417, digit=2),
         death = case_when(death == "No" ~ 0,
                           death == "Yes" ~ 1))
```

Merge the clinical information with the proteomics sample IDs

```{r}
df_meta_tmp <- df_final_ids %>% select(HCI_cID, cohort, final_sample_id) %>% 
  filter(final_sample_id %in% colnames(exprMatrix_corrected_sub)) # <------

meta_bridge <- df_meta_tmp %>% left_join(df_clin)
  
df_tmp <- df_pca %>% select(SampleID, cohort, HCI_cID) %>% distinct() %>% 
  rename(sample_id = SampleID)

meta_bridge2 <- meta_bridge %>% left_join(df_tmp) %>% 
  filter(cohort == "C_D") %>% 
  left_join(select(df_meta_f, HCI_cID, txt_stat)) 

# If we want just pre
meta_bridge_pre <- meta_bridge2 %>% 
  filter(txt_stat == "Pre")

# For patients with multiple samples, keep the sample closest before treatment date, per patient.
dupe_mrn <- meta_bridge_pre %>%
  count(mrn) %>%
  filter(n > 1)
tmp_df <- meta_bridge_pre %>% 
  filter(mrn %in% dupe_mrn$mrn)

# selecting the earilest collection date
# meta_bridge_pre <- meta_bridge_pre %>%
#   group_by(mrn) %>%
#   slice_min(collection_date, with_ties = FALSE) %>%
#   ungroup()

# selecting the closest to tx date
meta_bridge_pre <- meta_bridge_pre %>%
  mutate(days_diff = abs(as.numeric(difftime(collection_date, final_date, units = "days")))) %>%
  group_by(mrn) %>%
  slice_min(days_diff, with_ties = FALSE) %>%
  ungroup()

# Convert the gene x sample to the long NPX format
# Convert to long format
exprMatrix_long <- exprMatrix_corrected_sub %>% # <------
  as.data.frame() %>%
  rownames_to_column(var = "OlinkID") %>%  # Preserve row names as a column
  pivot_longer(cols = -OlinkID, names_to = "SampleID", values_to = "Value") %>% 
  left_join(df_pca) %>% 
  rename(NPX = Value)
```

Since we have serial patients, it would be incorrect to use repeated OS measurement for prognosis (violates the independent assumption of cox regression). An idea that for each protein, take the patient that has the highest expression of that protein (then discard the remaining serial samples). Next we can run the cox regression. This will means that duplicated proteins are not included. 

> Afeter talking to Manish and AC, a more logical approach is to use the baseline (pre-treatment) sample, if there are multiple pre-treatment, use the higest expressing one. 

## Univariate

Run the pre-txt mCRPC samples

```{r, warning=FALSE, message=FALSE}
# Select the highest expressing protein per- patient
tmp_npx <- exprMatrix_long 
results <- analyze_proteins_highest(cd_prot_sub, npx_in=tmp_npx, meta_in=meta_bridge_pre)
results <- left_join(results, df_id_pro)
res_bridge_limma_pre <- results
```

## Multi-variate

We use only the proteins considered significant at the uni-variate level

```{r}
uni_sig1 <- res_bridge_limma_pre %>% filter(P_Value < 0.05) %>% pull(OlinkID)
# We run all protein for now - we can filter later
uni_sig <- res_bridge_limma_pre$OlinkID
```

To simplify analysis on all proteins, we wrote a function. 

```{r, warning=FALSE, message=FALSE}
# Run function on multivariate analysis
results <- analyze_proteins_multi(uni_sig, npx_in=tmp_npx, meta_in=meta_bridge_pre)
results <- left_join(results, df_id_pro)
res_bridge_limma_pre_multi <- results
```


### Clean up

Format and save the results. 

```{r}
cox_p_val <- 0.05
res_bridge_limma_pre <- res_bridge_limma_pre %>% 
  mutate(Group = "Uni") %>% 
  mutate(
    Lower_Bound = round(Lower_Bound, 2),
    Upper_Bound = round(Upper_Bound, 2),
    bin_Lower_Bound = round(bin_Lower_Bound, 2),
    bin_Upper_Bound = round(bin_Upper_Bound, 2),
    
    HR = round(HR, 2),
    bin_HR = round(HR, 2),
    
    Sig_bin = case_when(
      #bin_P_Value <= cox_p_val & bin_Lower_Bound >=1 ~ "Sig",
      #bin_P_Value <= cox_p_val & bin_Lower_Bound <=1 & bin_Upper_Bound <=1 ~ "Sig",
      bin_P_Value <= cox_p_val & HR >= 1 ~ "Sig",
      TRUE ~ "Non"),
    
    fdr_cont = p.adjust(P_Value, method = "fdr"),
    
    Sig_fdr_cont = case_when(
      P_Value <= cox_p_val & HR >= 1 ~ "Sig",
      TRUE ~ "Non"))

write.csv(res_bridge_limma_pre, file.path(wd$outCurr, "HR_values_mCRPC_specific_UNI_variate_limma_pre.csv"))

cox_p_val <- 0.05
res_bridge_limma_pre_multi <- res_bridge_limma_pre_multi %>% 
  #filter(OlinkID %in% uni_sig1) %>% 
  mutate(Group = "Multi") %>% 
  mutate(
    Lower_Bound = round(Lower_Bound, 2),
    Upper_Bound = round(Upper_Bound, 2),
    bin_Lower_Bound = round(bin_Lower_Bound, 2),
    bin_Upper_Bound = round(bin_Upper_Bound, 2),
    
    HR = round(HR, 2),
    bin_HR = round(HR, 2),
    
    Sig_bin = case_when(
      #bin_P_Value <= cox_p_val & bin_Lower_Bound >=1 ~ "Sig",
      #bin_P_Value <= cox_p_val & bin_Lower_Bound <=1 & bin_Upper_Bound <=1 ~ "Sig",
      bin_P_Value <= cox_p_val & HR >= 1 ~ "Sig",
      TRUE ~ "Non"),
    
    fdr_cont = p.adjust(P_Value, method = "fdr"),
    
    Sig_fdr_cont = case_when(
      P_Value <= cox_p_val & HR >= 1 ~ "Sig",
      TRUE ~ "Non"))

write.csv(res_bridge_limma_pre_multi, file.path(wd$outCurr, "HR_values_mCRPC_specific_MULTI_variate_limma_pre.csv"))


```

Combine the uni and multi in one table

```{r}
uni_renamed <- res_bridge_limma_pre %>%
  select(OlinkID, Assay, Coefficient, Lower_Bound, Upper_Bound, P_Value, HR) %>%
  rename(
    Uni_Coefficient = Coefficient,
    Uni_Lower = Lower_Bound,
    Uni_Upper = Upper_Bound,
    Uni_P = P_Value,
    Uni_HR = HR
  ) %>% 
  mutate(Uni_Significant = case_when(
      Uni_P <= 0.05  ~ "Yes",
      TRUE ~ "No"))

multi_renamed <- res_bridge_limma_pre_multi %>%
  select(OlinkID, Coefficient, Lower_Bound, Upper_Bound, P_Value, HR) %>%
  rename(
    Multi_Coefficient = Coefficient,
    Multi_Lower = Lower_Bound,
    Multi_Upper = Upper_Bound,
    Multi_P = P_Value,
    Multi_HR = HR
  )   %>% mutate(Multi_Significant = case_when(
      Multi_P <= 0.05  ~ "Yes",
      TRUE ~ "No"))

combined <- left_join(uni_renamed, multi_renamed, by = "OlinkID")
```

## Add drug and CS


Overlap with CS data

```{r}
combined <- combined %>% 
  mutate(is_CS = case_when(Assay %in% cs$Approved.symbol ~ "Yes", TRUE ~ "No"))
res_all <- left_join(combined, cs, by = c("Assay" = "Approved.symbol"))
```

Add if the proteins are available on the Olink FLEX platform

```{r}
res_all <- res_all %>% 
  mutate(
    is_flex = case_when(Assay %in% df_flex$Gene ~ "Yes", TRUE ~ "No")) 
```

Also indicate if the protein is targetable

```{r}
df_target_sub <- df_target %>% select(Gene.Name, Drug.IDs) %>% 
  # Ensure one gene row for each drug
  group_by(Gene.Name) %>%
  summarise(
    DrugBank.ID = str_c(unique(unlist(str_split(Drug.IDs, ","))), collapse = ",")
  )
res_all2 <- res_all %>% left_join(df_target_sub, by = c("Assay" = "Gene.Name"))
```

Replace DrugID with common name

```{r}
df_vocab_sub <- df_vocab %>% select(DrugBank.ID, Common.name)
# Replace each DrugBank ID with the corresponding Common name
res_all2 <- res_all2 %>%
  # Split the Drug.IDs by semicolon
  mutate(DrugBank.ID = str_split(DrugBank.ID, "; ")) %>%
  # Use a custom function to replace IDs with common names
  mutate(drugname = sapply(DrugBank.ID, function(ids) {
    # Join the common names of the IDs in the list
    names <- df_vocab_sub %>% 
      filter(DrugBank.ID %in% ids) %>%
      pull(`Common.name`)
    # Combine the common names into a single string
    str_c(names, collapse = "; ")
  })) %>%
  mutate(DrugBank.ID = as.character(DrugBank.ID))  # Clean up the original Drug.IDs column if desired

write.csv(res_all2, file.path(wd$outCurr, "HR_values_mCRPC_specific_multivariate_limma_all_cell_surface.csv"))
```

