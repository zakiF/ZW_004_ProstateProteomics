---
title: "Initial analysis"
date: "2023-04-12"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: true
    toc_depth: 3
    number_sections: false
    theme: lumen
---

# Background

We have cohort of samples profiled for proteomics, genomics and metylation. We want to create a harmonized clinical file for all these patients.

In regards to proteomics. Samples were profiled ;

1) Psomagen cohort
2) Olink 2023 cohort (Q-13356) - Also called Project 2
3) Olink 2024 cohort (Q-15806) - Also called Project 4

In addition, some patients were also profiled by genomics (KLK2 SNPs) and methylation.

# Objectives

1. Gather data
2. Clean up clinical data
3. Viz of data

# Conclusion 

We extracted the metadata from 3 proteomics experiment. Identified samples to be used in future analysis. We have the final patient and sample numbers. 

# Pre-processing 

## Loading packages

```{r, message=FALSE, warning=FALSE}
library(here)
library(tidyverse)
library(readxl)   
library(readr)
library(stringr)

library(tidyverse)
library(ggplot2)
library(VennDiagram)
library(ggvenn)
```


## Directories

```{r}
wd <- list()
wd$main <- here()
wd$data <- file.path(wd$main, "data")
wd$manishData <- file.path(wd$data, "raw/data_fromManish")
wd$d2024 <- file.path(wd$data, "updated_2024")
wd$d2024_npx <- file.path(wd$d2024, "NPX_data")
wd$output <- file.path(wd$main, "output")
wd$script <- file.path(wd$main, "scripts")

wd$outData <- file.path(wd$output, "data")
wd$outCurr <- file.path(wd$output, "01_InitialAnalysis")
```


Create directories

```{r}
if (!file.exists(wd$outCurr)) {
  dir.create(wd$outCurr)
} else {
  print("Directory already exists")
}
```

Load functions

```{r}
source(file.path(wd$script, "functions.R"))
```


# Objective 1

**Gather data**

We start with the information that there are 312 samples sent for Proteomics profiling. For each patient, we have the HCI collection ID (HCI_cID) and the sample ID by Olink. 

We read the master file of all the HCI_cID into R

```{r}
df_hci_id <- read.csv(file.path(wd$d2024, "clinical_data/MetaData_Proteomics.csv"))
nrow(df_hci_id)
```

We also specify in the clinical file provided by Enos and Becky. This file is available in the cloud as well at - 

```{r}
meta_file <- file.path(wd$d2024, "clinical_data/Proteomic Demographic 06_23_25.xlsx")
```

This excel file contains a few sheets, each sheet represent the particular disease cohort. 

Next, for each the proteomics batch, we read in the NPX reading. 

## Psomagen 

**E3072_AN00003660_AN00003661_NPX_2022-04-21-columns**

This file is the NPX values from Olink. Samples are listed in the `SampleID` column

```{r}
# Read the files
dat_NPX <- readxl::read_excel(file.path(wd$d2024_npx, "batch_01_E3072_AN00003660_AN00003661_NPX_2022-04-21-columns.xlsx"))
```

Get Sample ID (listed in the `SampleID` column)

```{r}
b1_id <- unique(dat_NPX$SampleID)
length(b1_id)
```

There are `length(b1_id)` samples assayed by Olink. This includes "Sample Control" as well, an internal control used by Olink. 

Find the number of samples not including the internal control

```{r}
b1_noCtrl <- b1_id[!grepl("SC", b1_id)]
length(b1_noCtrl)
```

Lets check if there are equal number in our master sample sheet

```{r}
df_hci_id %>% filter(Psomagen == "Y") %>% nrow()
```

Its the same number of samples from NPX data and our sample information sheet. 

## Olink Q-13356 

**Q-13356_Kohli_EXTENDED_NPX_2024-03-11**

This file is the NPX values from Olink. Samples are listed in the `SampleID` column

Read the NPX data. Initially we read in this file - but this file was not "intensity normalized" rather it was "plate control" normalized. 

```{r}
# Read the files
# dat_NPX2 <- readr::read_delim(file.path(wd$d2024_npx, "batch_02_Q-13356_Kohli_EXTENDED_NPX_2024-03-11.csv"), delim = ";") 
```

We requested Olink to resend the "intensity normalzed" NPX, to match Psomagen data

```{r}
dat_NPX2 <- readr::read_delim(file.path(wd$d2024_npx, "Re_delivery_Intensity_based/Q-13356_Data Delivery/Q-13356_Kohli_Intensity_EXTENDED_NPX_2024-10-30.csv"), delim = ";")
```
Get Sample ID

```{r}
b2_id <- unique(dat_NPX2$SampleID)
length(b2_id)
```

There are `r `length(b2_id)` samples assayed by Olink. This includes "Sample Control" as well, an internal control used by Olink. 

Find the number of samples not including the internal control

```{r}
b2_noCtrl <- b2_id[!grepl("CONTROL_SAMPLE|NEG_CTRL|PLATE_CTRL", b2_id)]
length(b2_noCtrl)
```

Lets check if there are equal number of samples in our master sample sheet

```{r}
df_hci_id %>% filter(Q_13356 == "Y") %>% nrow()
```


Based on the NPX, we have `r length(b2_noCtrl)` samples. Meanwhile in the clinical file, we have 87. 

There is one less patient in the clinical sheet. 

Clarification was given by Claire 

> From: Claire Hanson <Claire.Hanson@hci.utah.edu>   
> Sent: Thursday, June 20, 2024 9:33 AM.  
To: Zaki Wilmot <zaki.wilmot@hci.utah.edu>; Manish Kohli <Manish.Kohli@hci.utah.edu>; Enos Ampaw <Enos.Ampaw@hci.utah.edu>   
> Subject: Re: Overlapping files
> 
> Hi Zaki, 
> 
> The duplicate sample is 34 and 78 (2021-2165). We used sample ID 34 as one of the bridging samples as well. 
> 
>Thanks, 
Claire 

We noted here that there is one sample missing a clinical ID. We go back to the email from Claire that mentioned the sample "2021-2165" was profiled twice and should have the assigned sample_id : 34 and 78 

```{r}
#filter(d2, is.na(HCI_cID))
```

We see sample ID 78 is missing clinical data. So we just exclude sample 78 for now

```{r}
#d2 <- d2 %>% 
#  filter(!sample_id_Q13356 == 78)
```



## Olink Q-15806


Read the NPX data. Samples are listed in the `SampleID` column

Again, similar to Q-13356, we have two NPX file based on the differnt normalization approach. We use the "intensity based" to keep it similar to Psomagen,

```{r}
# Read the files
#dat_NPX3 <- readr::read_delim(file.path(wd$d2024_npx, "Q-15806_Kohli_NPX_2024-07-29.csv"), delim = ";")
dat_NPX3 <- readr::read_delim(file.path(wd$d2024_npx, "Re_delivery_Intensity_based/Q-15806_Data Delivery/Q-15806_Kohli_EXTENDED_NPX_2024-10-30.csv"), delim = ";")
```

Get Sample ID

```{r}
b3_id <- unique(dat_NPX3$SampleID)
length(b3_id)
```

There are `r `length(b3_id)` samples assayed by Olink. This includes "Sample Control" as well, an internal control used by Olink. 

Find the number of samples not including the internal control.

```{r}
b3_noCtrl <-  b3_id[!grepl("CONTROL_SAMPLE|NEG_CTRL|PLATE_CTRL", b3_id)]
length(b3_noCtrl)
```

Lets check if there are equal number of samples in our master sample sheet

```{r}
df_hci_id %>% filter(Q_15806 == "Y") %>% nrow()
```


## Match protein IDs

Make a table of proteins and OlinkIDs

```{r}
d1 <- dat_NPX %>% select(OlinkID, Assay) %>% distinct() %>% 
  mutate(ID_assay = paste(OlinkID, Assay, sep="_"))
d2 <- dat_NPX2 %>% filter(!str_detect(Assay, "control")) %>% select(OlinkID, Assay) %>% distinct() %>% 
  mutate(ID_assay = paste(OlinkID, Assay, sep="_"))

d_all <- rbind(d1,d2) %>% distinct()


d_all <- d_all %>% 
  mutate(inPsom = if_else(ID_assay %in% d1$ID_assay, "Y", "N"),
         inQ1335 = if_else(ID_assay %in% d2$ID_assay, "Y", "N"))

write.csv(d_all, file.path(wd$outCurr, "Proteins_overlap.csv"))

```

We note there are three proteins with mis-match annotation, lets correct this

```{r}
d_all <- d_all %>% 
  mutate(
    Assay = case_when(
      OlinkID == "OID20125" ~ "NT-proBNP",
      OlinkID == "OID20857" ~ "CERT1",
      OlinkID == "OID21084" ~ "WARS1",
      TRUE ~ Assay))
  
# Create a list of Olink paired with protein ID
df_id_pro <- d_all %>% select(OlinkID, Assay) %>% distinct()

write.csv(df_id_pro, file.path(wd$outCurr, "Olink_assay_table.csv"))
```

# Objective 2

**Clean up clinical data**

Matt provided us with an cohort information in 30 May 2025. This contained information defining pre- and post- treated samples

```{r}
df_cohort <- read_xlsx(file.path(wd$d2024, "clinical_data/Cohort_grouping_2025_05_30.xlsx")) %>% 
  select(mrn:txt_stat) %>% 
  rename(Psomagen = Discovery,
         Q_13356 = Project_2,
         Q_15806 = Project_4)
```


## Cohort summary

Enos provided us with an updated clinical data. We stored this as `meta_file`.

Tab 1 contains cohort A. 
Tab 2 contains cohort B. 
Tab 3 contains cohort C. 

### Cohort A

For cohort A, lets get the HCI_cID and collection date

```{r}
df_clin <- read_xlsx(meta_file, sheet = 1)

dd <- df_clin
df_a <- data.frame(
  mrn = dd$`MRN (UUHSC)`,
  HCI_cID = c(dd$Sample1_HCI_Num, dd$Sample2_HCI_Num),
  date = c(dd$Sample1_date, dd$`Sample 2 Start date`)
  ) %>% filter(!is.na(HCI_cID)) %>% 
  mutate(cohort = "A") %>% 
  filter(HCI_cID %in% df_hci_id$HCI_cID)
```

### Cohort B

For cohort B, lets get the HCI_cID and collection date. We also want to add the treatment date. 

```{r}
df_clin <- read_xlsx(meta_file, sheet = 2)

dd <- df_clin

df_b <- data.frame(
  mrn = dd$`MRN (UUHSC)`,
  HCI_cID = c(dd$Sample1_HCI_Num, dd$Sample2_HCI_Num, dd$Sample3_HCI_Num),
  date = c(dd$Sample1_date, dd$`Sample 2 Start date`, dd$`sample3 date`),
  psa = c(dd$sample1_psa, dd$sample2_psa, dd$sample3_psa),
  testo = c(dd$sample1_testos, dd$`Sample 2 Testerone`, dd$`Sample 3 Testosterone`), 
  txt_ori = dd$txt_stat,
  death_date = c(dd$`Death date`),
  death_status = dd$`Deceased?`,
  txt_nhspc_1st_type = dd$`1st_nmhspc_rx`,
  txt_nhspc_1st_date = dd$`1st_nmhspc_rx_date`,
  txt_mhspc_1st_type = dd$`1st_mhspc_rx`,
  txt_mhspc_1st_date = dd$`1st_mhspc_rx_date`,
  txt_mhspc_2st_type = dd$`2nd_mhspc_rx`,
  txt_mhspc_2st_date = dd$`2nd_mhspc_rx_date`
) %>% 
  filter(!is.na(HCI_cID)) %>% 
  mutate(
    cohort = "B",
    psa = as.numeric(gsub("<", "", psa)),
    testo = as.numeric(gsub("<", "", testo))
  ) %>% 
  filter(HCI_cID %in% df_hci_id$HCI_cID)
```

We want to figure out when is the first ADT date that is given. Lets first list all the treatments given and figure out which one is ADT.

```{r}
# Create columns indicating if ADT was given and the earliest date of ADT given for each patient
df_b2 <- df_b %>%
  mutate(
    # Identify if each treatment type is ADT
    nhspc_adt = str_detect(tolower(txt_nhspc_1st_type), "adt"),
    mhspc1_adt = str_detect(tolower(txt_mhspc_1st_type), "adt"),
    mhspc2_adt = str_detect(tolower(txt_mhspc_2st_type), "adt"),
    # Convert all treatment dates to Date type
    nhspc_adt_date = if_else(nhspc_adt, as.Date(txt_nhspc_1st_date), as.Date(NA)),
    mhspc1_adt_date = if_else(mhspc1_adt, as.Date(txt_mhspc_1st_date), as.Date(NA)),
    mhspc2_adt_date = if_else(mhspc2_adt, as.Date(txt_mhspc_2st_date), as.Date(NA))
  ) %>%
  rowwise() %>%
  mutate(
    # Was ADT given in any of the three?
    adt_given = any(c(nhspc_adt, mhspc1_adt, mhspc2_adt), na.rm = TRUE),
    # Find the earliest date of ADT given
    adt_earliest_date = min(c(nhspc_adt_date, mhspc1_adt_date, mhspc2_adt_date), na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    # If no ADT was given, set adt_earliest_date to NA
    adt_earliest_date = if_else(adt_given, adt_earliest_date, as.Date(NA))
  )

df_b2 <- df_b %>%
  mutate(
    # Identify if each treatment type is ADT
    nhspc_adt = str_detect(tolower(txt_nhspc_1st_type), "adt"),
    mhspc1_adt = str_detect(tolower(txt_mhspc_1st_type), "adt"),
    mhspc2_adt = str_detect(tolower(txt_mhspc_2st_type), "adt"),
    # Convert all treatment dates to Date type
    nhspc_adt_date = if_else(nhspc_adt, as.Date(txt_nhspc_1st_date), as.Date(NA)),
    mhspc1_adt_date = if_else(mhspc1_adt, as.Date(txt_mhspc_1st_date), as.Date(NA)),
    mhspc2_adt_date = if_else(mhspc2_adt, as.Date(txt_mhspc_2st_date), as.Date(NA))
  ) %>%
  rowwise() %>%
  mutate(
    # Was ADT given in any of the three?
    adt_given = any(c(nhspc_adt, mhspc1_adt, mhspc2_adt), na.rm = TRUE),
    # Find the earliest and latest date of ADT given
    adt_earliest_date = min(c(nhspc_adt_date, mhspc1_adt_date, mhspc2_adt_date), na.rm = TRUE),
    adt_latest_date   = max(c(nhspc_adt_date, mhspc1_adt_date, mhspc2_adt_date), na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(
    # If no ADT was given, set adt_earliest_date and adt_latest_date to NA
    adt_earliest_date = if_else(adt_given, adt_earliest_date, as.Date(NA)),
    adt_latest_date   = if_else(adt_given, adt_latest_date, as.Date(NA)))
```

Now we want to create a column to indicate if the patient was given ADT within 30 days of the sample collecton date. For samples before the 30 days, label as Pre and after 30 days label as post. 

For some patients (with >90 days since ADT) Bekcy provided us with an updated ADT date as well. We read this updated dates

```{r}
df_adt <- read_xlsx(file.path(wd$d2024, "clinical_data/ADT_timeline_HSPC.xlsx"), sheet=1)
```

Based on the HCI_cID, we want to replace the ADT collection date to Becky's date. We replace the adt_earliest_date with the dates provided by Becky.

```{r}
df_b2 <- df_b2 %>%
  left_join(df_adt %>% select(HCI_cID, Becky_ADT_date), by = "HCI_cID") %>%
  mutate(
    adt_earliest_date = if_else(!is.na(Becky_ADT_date), as.Date(Becky_ADT_date), adt_earliest_date)
  ) %>%
  select(-Becky_ADT_date)
```

Lets calcualte the time of sample collection to ADT

```{r}
df_b2 <- df_b2 %>%
  mutate(
    # Calculate days from sample collection to ADT
    days_to_adt_early = as.numeric(difftime(date, adt_earliest_date, units = "days")),
    days_to_adt_late  = as.numeric(difftime(date, adt_latest_date, units = "days")),
    # Label as Pre if sample is within 30 days before/after earliest ADT, Post if >30 days after earliest ADT
    adt_status_early = case_when(
      is.na(adt_earliest_date) ~ "Pre",                # No ADT date available
      days_to_adt_early >= -30 & days_to_adt_early <= 30 ~ "Pre",  # Within 30 days before/after earliest ADT
      days_to_adt_early > 30 ~ "Post",                       # More than 30 days after earliest ADT
      days_to_adt_early < -30 ~ "Pre",                       # More than 30 days before earliest ADT 
      TRUE ~ NA_character_),
    adt_status_late = case_when(
      is.na(adt_latest_date) ~ "Pre",                # No ADT date available
      days_to_adt_late >= -30 & days_to_adt_late <= 30 ~ "Pre",  # Within 30 days before/after earliest ADT
      days_to_adt_late > 30 ~ "Post",                       # More than 30 days after earliest ADT
      days_to_adt_late < -30 ~ "Pre",                       # More than 30 days before earliest ADT 
      TRUE ~ NA_character_)
  )
```

When we compare if the Pre- or Post- is the same using early or late. 3 patients were different ;

- 2021-1600 
- 2020-3493 
- 2021-2049 

For now, we are using the days_to_adt_early to define the ADT status. Additionally, we are now considering the testosterone level as well. 

Anything labeled initially as "Pre" and have a testo value <50 will be considered "Post" 

Anything labeled initially as "Post" and have a testo value >50 will be considered as "Pre"

```{r}
df_b3 <- df_b2 %>% 
  mutate(
    updated_adt_early = case_when(
      adt_status_early == "Pre" & testo  <= 50 ~ "Post",
      adt_status_early == "Post" & testo  > 50 ~ "Pre",
      TRUE ~ adt_status_early
    )
  )
```

Number of samples in pre- or post-

```{r}
table(df_b3$updated_adt_early)
```

Lets check how many pre- post- pairs we have

```{r}
mrn_pre_post <- df_b3 %>%
  group_by(mrn) %>%
  summarise(
    has_pre = as.integer(any(updated_adt_early == "Pre", na.rm = TRUE)),
    has_post = as.integer(any(updated_adt_early == "Post", na.rm = TRUE))
  )

# View only those with both Pre and Post
mrn_pre_post %>%
  filter(has_pre == 1 & has_post == 1) %>% 
  dim()
```

### Cohort C

For cohort C, lets get the HCI_cID and collection date. We also want to add the treatment date. 

```{r}
df_clin <- read_xlsx(meta_file, sheet = 5)

dd <- df_clin

df_c <- data.frame(
  mrn = dd$`MRN (UUHSC)`,
  HCI_cID = c(dd$Sample1_HCI_Num, dd$Sample2_HCI_Num, dd$Sample3_HCI_Num),
  date = c(dd$Sample1_date, dd$`Sample 2 Start date`, dd$`Sample3_Start date`),
  psa = c(dd$sample1_psa, dd$sample2_psa, dd$sample3_psa),
  ldh = c(dd$sample1_ldh, dd$sample2_ldh, dd$sample3_ldh),
  alk_phos = c(dd$sample1_alk_phos, dd$sample2_alk_phos, dd$sample3_alk_phos),
  death_date = c(dd$`Death date`),
  death_status = dd$`Deceased?`,
  txt_nmcrpc_1st_type = dd$`1st_nmcrpc_rx`,
  txt_nmcrpc_1st_date = dd$`1st_nmcrpc_rx_date`,
  txt_mcrpc_1st_type = dd$`1st_mcrpc_rx`,
  txt_mcrpc_1st_date = dd$`1st_mcrpc_rx_date`,
  txt_mcrpc_2st_type = dd$`2nd_mcrpc_rx`,
  txt_mcrpc_2st_date = dd$`2nd_mcrpc_rx_date`
) %>% 
  filter(!is.na(HCI_cID)) %>% 
  mutate(
    cohort = "C",
    psa = as.numeric(gsub("<", "", psa)),
    ldh = as.numeric(gsub("<", "", ldh)),
    alk_phos = as.numeric(gsub("<", "", alk_phos)),
  ) %>% 
  filter(HCI_cID %in% df_hci_id$HCI_cID)
```

We want to figure out when is the first CRPC treatment is given. Regardless of what CRPC treatment was given

```{r}
# If any treatment is given, find the earliest and latest treatment date.

# Cohort C: Find earliest and latest treatment date (any treatment)
df_c2 <- df_c %>%
  mutate(
    # Convert all treatment dates to Date type
    nmcrpc_date = as.Date(txt_nmcrpc_1st_date),
    mcrpc1_date = as.Date(txt_mcrpc_1st_date),
    mcrpc2_date = as.Date(txt_mcrpc_2st_date)
  ) %>%
  rowwise() %>%
  mutate(
    # Find the earliest and latest date of any treatment given
    any_treatment_earliest_date = min(c(nmcrpc_date, mcrpc1_date, mcrpc2_date), na.rm = TRUE),
    any_treatment_latest_date   = max(c(nmcrpc_date, mcrpc1_date, mcrpc2_date), na.rm = TRUE),
    # Was any treatment given? (at least one non-NA date)
    any_treatment_given = any(!is.na(c(nmcrpc_date, mcrpc1_date, mcrpc2_date)))
  ) %>%
  ungroup() %>%
  mutate(
    # If no treatment was given, set dates to NA
    any_treatment_earliest_date = if_else(any_treatment_given, any_treatment_earliest_date, as.Date(NA)),
    any_treatment_latest_date   = if_else(any_treatment_given, any_treatment_latest_date, as.Date(NA))
  )
```

Now we want to create a column to indicate if the patient was given mCRPC treament within 30 days of the sample collection date. For samples wihtin 30 days (before or after the 30 days), label as Pre and after 30 day window label as post. 

Lets calcualte the time of sample collection to treatment

```{r}
df_c2 <- df_c2 %>%
  mutate(
    # Calculate days from sample collection to earliest and latest mCRPC (any) treatment
    days_to_mcrpc_early = as.numeric(difftime(date, any_treatment_earliest_date, units = "days")),
    days_to_mcrpc_late  = as.numeric(difftime(date, any_treatment_latest_date, units = "days")),
    # Label as Pre if sample is within 30 days before/after earliest mCRPC treatment, Post if >30 days after earliest mCRPC treatment
    mcrpc_status_early = case_when(
      is.na(any_treatment_earliest_date) ~ "Pre",                # No mCRPC treatment date available
      days_to_mcrpc_early >= -30 & days_to_mcrpc_early <= 30 ~ "Pre",  # Within 30 days before/after earliest mCRPC treatment
      days_to_mcrpc_early > 30 ~ "Post",                       # More than 30 days after earliest mCRPC treatment
      days_to_mcrpc_early < -30 ~ "Pre",                       # More than 30 days before earliest mCRPC treatment 
      TRUE ~ NA_character_),
    mcrpc_status_late = case_when(
      is.na(any_treatment_latest_date) ~ "Pre",                # No mCRPC treatment date available
      days_to_mcrpc_late >= -30 & days_to_mcrpc_late <= 30 ~ "Pre",  # Within 30 days before/after latest mCRPC treatment
      days_to_mcrpc_late > 30 ~ "Post",                       # More than 30 days after latest mCRPC treatment
      days_to_mcrpc_late < -30 ~ "Pre",                       # More than 30 days before latest mCRPC treatment 
      TRUE ~ NA_character_)
  )
```

Number of samples in pre- or post-

```{r}
table(df_c2$mcrpc_status_early)
```

Lets check how many pre- post- pairs we have

```{r}
mrn_pre_post <- df_c2 %>%
  group_by(mrn) %>%
  summarise(
    has_pre = as.integer(any(mcrpc_status_early == "Pre", na.rm = TRUE)),
    has_post = as.integer(any(mcrpc_status_early == "Post", na.rm = TRUE))
  )

# View only those with both Pre and Post
mrn_pre_post %>%
  filter(has_pre == 1 & has_post == 1) %>% 
  dim()
```

# Objective 3

*Viz of data*

Lets summarize the data with some plots

Create a master file to see the treatment status and collection date of all samples

```{r}
d1 <- df_a %>% 
  mutate(txt_stat = "Pre",
         time2txt = 0) 
d2 <- df_b3 %>% select(mrn, HCI_cID, date, cohort, updated_adt_early, days_to_adt_early) %>% 
  rename(txt_stat = updated_adt_early,
         time2txt= days_to_adt_early)
d3 <- df_c2 %>% select(mrn, HCI_cID, date, cohort, mcrpc_status_early, days_to_mcrpc_early) %>% 
  rename(txt_stat = mcrpc_status_early,
         time2txt = days_to_mcrpc_early)

df_meta_f <- rbind(d1,d2,d3) %>% 
  left_join(df_hci_id %>% select(-mrn, -X))
```

## Venn overlap

Lets get a Venn diagram of the number of samples in each batch

```{r}
un_a <- df_meta_f %>% filter(Psomagen == "Y") %>% pull(HCI_cID)
un_b <- df_meta_f %>% filter(Q_13356 == "Y") %>% pull(HCI_cID)
un_c <- df_meta_f %>% filter(Q_15806 == "Y") %>% pull(HCI_cID)

l_all <- list(
  Psomagen = un_a,
  Q_13356 = un_b,
  Q_15806 = un_c
)

overlap <- calculate.overlap(
x <- list("Psomagen"=un_a, 
          "Q_13356"=un_b,
          "Q_15806"=un_c))

pdf(file=file.path(wd$outCurr, "Samples_venn_overlap.pdf"), width = 5, height = 5)
ggvenn(
  x, 
  fill_color = pal.study,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)
dev.off()

un_a <- df_meta_f %>% filter(Psomagen == "Y") %>% pull(mrn) %>% unique()
un_b <- df_meta_f %>% filter(Q_13356 == "Y") %>% pull(mrn) %>% unique()
un_c <- df_meta_f %>% filter(Q_15806 == "Y") %>% pull(mrn) %>% unique()

l_all <- list(
  Psomagen = un_a,
  Q_13356 = un_b,
  Q_15806 = un_c
)

overlap <- calculate.overlap(
x <- list("Psomagen"=un_a, 
          "Q_13356"=un_b,
          "Q_15806"=un_c))

pdf(file=file.path(wd$outCurr, "Patient_venn_overlap.pdf"), width = 5, height = 5)
ggvenn(
  x, 
  fill_color = pal.study,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)
dev.off()
```

## Num samples

```{r}
# Step 1: Summarize the data (count samples for each cohort and txt_stat combination)
summary_df <- df_meta_f %>%
  mutate(txt_stat = gsub("[1-2]", "", txt_stat),
         txt_stat = gsub("post", "Post", txt_stat)) %>% 
  group_by(cohort, txt_stat) 

pr1.1 <- print(paste0("Num of patients in All is ", length(unique(summary_df$mrn))))
pr1.2 <- print(paste0("Num of samples in All is ", length(unique(summary_df$HCI_cID))))

summary_df1 <- summary_df %>% 
  summarise(count = n(), .groups = 'drop') %>% 
  # Create a new column that combines cohort and txt_stat
  mutate(cohort_txt_stat =
           paste(cohort, txt_stat, sep = "_"),
         cohort_txt_stat = factor(cohort_txt_stat, levels=c(
           "A_Pre", "A_Post", "B_Pre", "B_Post", "C_Pre", "C_Post"
         ))) %>% 
  mutate(Batch = "01_All_cohort")

# Custom colors: you can choose shades inspired by Tableau colors
custom_colors <- c(
  "A_Pre" = "#1f77b4", "A_Post" = "#aec7e8",  # Blue shades
  "B_Pre" = "#ff7f0e", "B_Post" = "#ffbb78",  # Orange shades
  "C_Pre" = "#2ca02c", "C_Post" = "#98df8a"  # Green shades
)

# Updated plot
p1 <- ggplot(summary_df1, aes(x = cohort_txt_stat, y = Batch, size = count, fill = cohort_txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  # Create circles with black border
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  scale_size_area(max_size = 15) +  # Adjust circle sizes
  scale_fill_manual(values = custom_colors) +  # Set custom colors
  labs(x = "Cohort", y = "", fill = "Cohort and txt_stat", size = "Sample Count") +  # Label x-axis and legend
  theme_bw() +  # Clean background
  theme(legend.position = "right", axis.ticks.y = element_blank(),
        panel.grid = element_blank())
ggsave(p1, file=file.path(wd$outCurr, "Treatment_breakdown.pdf"), height = 5, width = 7)
p1
```

## Longtidudinal 

Lets plot the distribution of samples. To see how many are longtiduinal samples. Ie - same mrn, profiled pre- and post- treatment. 

```{r}
# Identify patients groups ;
# Group 1 - mrn that occurs 1x
# Group 2 - mrn that occurs 2x
#   -2B - mrn 2x in cohort B 
#   -2C - mrn 2x in cohort C_D
#   -2D - mrn 1x in cohort B & 1x in cohort C_D
# Group 3 - mrn that occurs 3x

df_tally <- df_meta_f 

df_tally_tmp <- df_tally %>%
  select(mrn, HCI_cID, cohort) %>% distinct()

mrn_counts <- df_tally_tmp %>%
  group_by(mrn, cohort) %>%
  summarise(count = n(), .groups = 'drop') %>%
  pivot_wider(names_from = cohort, values_from = count, values_fill = 0)

tot_counts <- df_meta_f %>%
  group_by(mrn) %>% 
  summarise(total_observations = n())

mrn_counts <- mrn_counts %>% left_join(tot_counts)



group_1_mrns <- mrn_counts %>% filter(total_observations == 1) %>% pull(mrn)
group_2_mrns <- mrn_counts %>% filter(total_observations == 2)
group_2_cohort_B <- group_2_mrns %>% filter(B == 2) %>% pull(mrn)
group_2_cohort_C <- group_2_mrns %>% filter(C == 2) %>% pull(mrn)
group_2_mrns_set2 <- group_2_mrns %>% filter(B == 1 & B == 1) %>% pull(mrn)

# -- Group 2--- 
df_group2 <- df_meta_f %>%
  filter(mrn %in% group_2_cohort_B) %>% 
  select(mrn, HCI_cID, cohort, txt_stat) %>% arrange(mrn, cohort, txt_stat)


# Making a function, to avoid repetition
# Define a function that processes a cohort
process_cohort <- function(df_meta_f, cohort_mrns, prefix, start_group) {
  # Step 1: Filter and arrange
  df_cohort <- df_meta_f %>%
    filter(mrn %in% cohort_mrns) %>%
    select(mrn, HCI_cID, cohort, txt_stat) %>%
    arrange(mrn, cohort, txt_stat)
  
  # Step 2: Create the pattern for each mrn
  df_cohort <- df_cohort %>%
    group_by(mrn) %>%
    arrange(cohort, txt_stat) %>%
    mutate(pattern = paste(cohort, txt_stat, collapse = "-")) %>%
    ungroup()
  
  # Step 3: Assign groups based on unique patterns
  unique_patterns <- df_cohort %>%
    distinct(pattern) %>%
    mutate(group = paste0(prefix, LETTERS[start_group + row_number() - 1]))
  
  # Step 4: Merge group information back
  df_cohort <- df_cohort %>%
    left_join(unique_patterns, by = "pattern")
  
  # Return the dataframe and the last group number used
  df_cohort_tmp <- df_cohort %>% select(mrn, group) %>% distinct()
  last_group <- start_group + nrow(unique_patterns) - 1
  
  list(df_cohort_tmp = df_cohort_tmp, last_group = last_group)
}

# Process Group 2B (group_2_cohort_B)
result_B <- process_cohort(df_meta_f, group_2_cohort_B, "Group 2", 1)

# Process Group 2C starting from the next group after Group 2B
result_C <- process_cohort(df_meta_f, group_2_cohort_C, "Group 2", result_B$last_group + 1)

result_CD <- process_cohort(df_meta_f, group_2_mrns_set2, "Group 2", result_C$last_group + 1)

# Combine the results
df_group2_combined <- bind_rows(result_B$df_cohort_tmp, result_C$df_cohort_tmp, result_CD$df_cohort_tmp)


# ---- Group 3 ---- #
# Step 1: Get unique combinations of mrn, cohort, and txt_stat
group_4_mrns <- mrn_counts %>% filter(total_observations == 3) %>% pull(mrn)
df_group4 <- df_meta_f %>%
  filter(mrn %in% group_4_mrns) %>% 
  select(mrn, HCI_cID, cohort, txt_stat) %>% arrange(mrn, cohort, txt_stat)


# data_labeled <- df_group4 %>%
#   group_by(mrn, txt_stat) %>%
#   mutate(txt_stat = ifelse(row_number() == 1, txt_stat, paste0(txt_stat, row_number()))) %>%
#   ungroup()


# Step 1: Create a unique pattern by combining cohort and txt_stat for each mrn
# This creates a pattern for each mrn's cohort-txt_stat combination
df_group4 <- df_group4 %>%
  group_by(mrn) %>%
  arrange(cohort, txt_stat) %>%  # Ensure consistent order
  mutate(pattern = paste(cohort, txt_stat, collapse = "-")) %>%
  ungroup()

# Step 2: Assign groups based on unique patterns
# We create a lookup table where each unique pattern is assigned a group
unique_patterns <- df_group4 %>%
  distinct(pattern) %>%
  mutate(group = paste0("Group 3", LETTERS[row_number()]))


# Step 3: Merge the group information back into the original data
df_group4 <- df_group4 %>%
  left_join(unique_patterns, by = "pattern")
df_group4_tmp <- df_group4 %>% select(mrn, group) %>% distinct()

dat_group <- data.frame(
  mrn = c(group_1_mrns, 
          df_group2_combined$mrn,
          df_group4_tmp$mrn),
  group = c(
    rep("Group 1", each=length(group_1_mrns)),
    df_group2_combined$group,
    df_group4_tmp$group)
)

data <- df_meta_f %>% 
  #select(mrn, HCI_cID, cohort, txt_stat) %>% distinct() %>% 
  left_join(dat_group)

# Label consequtive pre or post
data <- data %>%
  group_by(mrn, txt_stat) %>%
  mutate(txt_stat = ifelse(row_number() == 1, txt_stat, paste0(txt_stat, row_number()))) %>%
  ungroup() %>% 
  mutate(txt_stat = factor(txt_stat, levels=c("Pre", "Pre2", "Post", "Post2", "Post3")))

df_pre_post <- data
df_pre_post_tmp <- df_pre_post %>%   
  dplyr::rename(SampleID = sample_id_psom) %>% 
  select(cohort, SampleID, txt_stat) %>% 
  mutate(SampleID = as.character(SampleID)) %>% 
  distinct()

data2 <- data %>% group_by(group, cohort, txt_stat) %>% 
  arrange(group) %>% 
  summarize(count = n()) %>% 
  mutate(group = factor(group, levels = (unique(group))))


ggplot(data2, aes(x=cohort, y=group, size=count, fill=txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL

# Custom colors
# Create a new column that combines cohort and txt_stat
data2 <- data2 %>% 
  mutate(cohort_txt_stat =paste(cohort, txt_stat, sep = "_"),
         cohort_txt_stat = factor(cohort_txt_stat, levels=unique(cohort_txt_stat))) 

# Custom colors: you can choose shades inspired by Tableau colors
custom_colors <- c(
  "A_Pre" = "#1f77b4", "A_Post" = "#aec7e8",  # Blue shades
  "B_Pre" = "#ff7f0e", "B_Post" = "#ffbb78", "B_Post2" = "#ffbb78", # Orange shades
  "C_Pre" = "#2ca02c", "C_Pre2" = "#2ca02c", 
  "C_Post" = "#98df8a",  "C_Post2" = "#98df8a", "C_Post3" = "#98df8a" # Green shades
)

ggplot(data2, aes(x=cohort, y=group, size=count, fill=cohort_txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(values = custom_colors) +  # Set custom colors 
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL

p2 <- 
ggplot(data2, aes(x=cohort, y=group, size=count, fill=txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  scale_size_area(max_size = 15) +  # Adjust circle sizes
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(values = c("Pre" = "lightblue", "Pre2" = "lightblue", 
                               "Post" = "orange", "Post2"= "orange")) +  # Set fill colors
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL


ggsave(p2, file=file.path(wd$outCurr, "Treatment_grouping_pattern_updated.pdf"), height = 5, width = 12)

write.csv(data, file.path(wd$outCurr, "Treatment_grouping_pattern_updated.csv"))

df_pre_post_ori <- df_pre_post
```

In the local stage, lets group all together. So the plots are on the same scale. Also add the total number of samples

```{r}
# Sum of A (Pre + Post)
sum_A <- data2 %>%
  filter(cohort == "A") %>%
  summarise(total = sum(count)) %>%
  pull(total)

# Create Group 0
# First, summarize "pre/post" status for each cohort
group_0 <- data2 %>%
  mutate(
    txt_stat_grouped = case_when(
      str_detect(txt_stat, regex("pre", ignore_case = TRUE)) ~ "Pre",
      str_detect(txt_stat, regex("post", ignore_case = TRUE)) ~ "Post",
      TRUE ~ as.character(txt_stat)
    )
  ) %>%
  group_by(cohort, txt_stat_grouped) %>%
  summarise(count = sum(count), .groups = "drop") %>%
  
  # Special step: handle A separately
  mutate(
    count = if_else(cohort == "A",
                    sum(count[cohort == "A"]),
                    count)
  ) %>%
  
  mutate(
    group = "Group 01",
    cohort_txt_stat = paste0(cohort, "_", txt_stat_grouped)
  ) %>%
  select(group, cohort, txt_stat = txt_stat_grouped, count, cohort_txt_stat)



# Bind Group 1 and Group 0 together
df_new <- bind_rows(data2, group_0) %>% ungroup %>% distinct()

# Extend view
df_new <- df_new %>%
  bind_rows(tibble(
    group = "Group 00",
    cohort = "A",
    txt_stat = "Pre",
    count = NA,
    cohort_txt_stat = "A_Pre"
  )) %>% mutate(
    txt_stat = factor(txt_stat, levels=c("Pre", "Pre2", "Post", "Post2")),
    cohort_txt_stat = factor(cohort_txt_stat, 
                             levels=c("A_Pre", "A_Post",
                                      "B_Pre", "B_Post", "B_Post2",
                                      "C_Pre", "C_Pre2", "C_Post", "C_Post2, C_Post3"
                                      ))
  )

tmp_width <- 0
p2 <- 
ggplot(df_new, aes(x=cohort_txt_stat, y=group, size=count, fill=cohort_txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=tmp_width)) +  
  scale_size_area(max_size = 15) +  # Adjust circle sizes
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=tmp_width)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(
    values = c("A_Pre" = "lightblue", "A_Pre2" = "lightblue", 
               "B_Pre" = "lightblue", "B_Pre2" = "lightblue", 
               "C_Pre" = "lightblue", "C_Pre2" = "lightblue", 
               "A_Post" = "orange", "A_Post2"= "orange",
               "B_Post" = "orange", "B_Post2"= "orange",
               "C_Post" = "orange", "C_Post2"= "orange", "C_Post"= "orange")
    ) +  # Set fill colors
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=tmp_width)) +  # Add text underneath circlesNULL
  NULL


ggsave(p2, file=file.path(wd$outCurr, "Treatment_grouping_pattern_all.pdf"), height = 5, width = 12)
```


```{r}
# Number of cohort B unique patients
df_meta_f %>% filter(cohort == "B") %>% pull(mrn) %>% unique() %>% length()

# Number of cohort C unique patients
df_meta_f %>% filter(cohort == "C") %>% pull(mrn) %>% unique() %>% length()

# Number of cohort C samples
df_meta_f %>% filter(cohort == "C") %>% nrow()
```

Make a simple barplot to summarize the data. Two columns per cohort. Number of patients & number of samples. 

```{r}
# Calculate overlap between B and C_D cohorts
overlap_patients <- df_meta_f %>%
  filter(cohort %in% c("B", "C")) %>%
  group_by(mrn) %>%
  filter(n_distinct(cohort) > 1) %>%
  pull(mrn) %>%
  unique()

# Create summary data frame
summary_data <- df_meta_f %>%
  group_by(cohort) %>%
  summarise(
    n_patients = n_distinct(mrn),
    n_samples = n()
  ) %>%
  pivot_longer(
    cols = c(n_patients, n_samples),
    names_to = "metric",
    values_to = "count"
  )

# Create the barplot
p_bar <- ggplot(summary_data, aes(x = cohort, y = count, fill = metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.7), width = 0.6) +
  # Add overlay for C_D cohort showing overlap (only for patients)
  geom_bar(
    data = filter(summary_data, cohort == "C" & metric == "n_patients"),
    aes(y = length(overlap_patients), fill = "Overlap with B"),
    stat = "identity",
    position = position_dodge(width = 0.7),
    width = 0.6,
    alpha = 0.5
  ) +
  scale_fill_manual(
    values = c(
      "n_patients" = "#faedcd",
      "n_samples" = "grey60",
      "Overlap with B" = "darkred"
    ),
    labels = c("Number of Patients", "Number of Samples", "Overlap with B")
  ) +
  labs(
    x = "Cohort",
    y = "Count",
    fill = "Metric"
  ) +
  theme_bw() +
  theme(
    legend.position = "right",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  geom_text(
    aes(label = count),
    position = position_dodge(width = 0.7),
    vjust = -0.5,
    size = 4
  ) +
  # Add annotation for overlap
  annotate(
    "text",
    x = "C_D",
    y = length(overlap_patients),
    label = paste("Overlap:", length(overlap_patients)),
    vjust = -0.5,
    size = 4,
    color = "darkred"
  )

ggsave(p_bar, file=file.path(wd$outCurr, "Patients_number_bar.pdf"), height = 5, width = 7)
```

## Swimmers plot 

Make a timeline for each patient

```{r edited_swimmer, message=FALSE, warning=FALSE}
# 1. Define the pattern assignment function
# In the functions.R script

# 2. Define the pattern order
# In the functions.R script

# 3. Relabel txt_stat as Pre1, Pre2, Post1, etc. by date within each patient/cohort/status
df_meta_f2 <- df_meta_f %>%
  group_by(mrn, cohort, txt_stat) %>%
  arrange(date, .by_group = TRUE) %>%
  mutate(
    txt_stat_ordered = paste0(txt_stat, row_number())
  ) %>%
  ungroup()

# 4. Assign pattern to each sample
patient_patterns <- get_patient_pattern(df_meta_f2 %>% mutate(txt_stat = txt_stat_ordered))
df_meta_f2 <- df_meta_f2 %>%
  left_join(patient_patterns %>% select(mrn, pattern, total_samples), by = "mrn")

dplyr::filter(df_meta_f2, mrn == "6911366") %>% select(mrn, HCI_cID, txt_stat, txt_stat_ordered)
dplyr::filter(patient_patterns, mrn == "6911366") %>% as.data.frame()

# 5. Order patients by pattern and total_samples
ordered_mrns <- df_meta_f2 %>%
  distinct(mrn, pattern, total_samples) %>%
  arrange(
    factor(pattern, levels = pattern_order),
    desc(total_samples)
  ) %>%
  pull(mrn)

# 6. Prepare swimmers_data with correct offsets and positions
swimmers_data <- df_meta_f2 %>%
  mutate(
    base_pos = case_when(
      cohort == "A" ~ 0,
      cohort == "B" ~ 1,
      cohort == "C" ~ 2
    ),
    # Extract trailing number from txt_stat_ordered, default to 1 if missing
    sample_num = as.numeric(str_extract(txt_stat_ordered, "\\d+$")),
    sample_num = ifelse(is.na(sample_num), 1, sample_num),
    # Offset for multiple samples of the same type
    x_offset = (sample_num - 1) * 0.2,
    # Treatment offset: Pre left, Post right
    treatment_offset = case_when(
      grepl("^Pre", txt_stat_ordered) ~ -0.2,
      grepl("^Post", txt_stat_ordered) ~ 0.2,
      TRUE ~ 0
    ),
    # Final x position, shifted to avoid 1/2 dashed line
    x_pos = base_pos + treatment_offset + x_offset - 0.05,
    # y position based on patient order
    y_pos = match(mrn, ordered_mrns),
    # For labeling
    sample_label = txt_stat_ordered
  )

# 7. Rectangle data for cohort boxes
rect_data <- data.frame(
  cohort = c("A", "B", "C"),
  xmin = c(-0.5, 0.5, 1.5),
  xmax = c(0.5, 1.5, 2.5)
)

# 8. Swimmers plot with time2txt above each point
p_swimmers_ordered <- ggplot(swimmers_data, aes(x = x_pos, y = y_pos)) +
  geom_rect(
    data = rect_data,
    inherit.aes = FALSE,
    aes(xmin = xmin, xmax = xmax, ymin = 0, ymax = max(swimmers_data$y_pos) + 1),
    fill = "grey95",
    alpha = 0.5
  ) +
  geom_vline(
    xintercept = c(0, 1, 2),
    linetype = "dashed",
    color = "grey50",
    alpha = 0.5
  ) +
  geom_point(
    aes(color = txt_stat_ordered),
    size = 3,
    shape = 16
  ) +
  geom_text(
    aes(label = time2txt),
    vjust = -1,
    size = 3
  ) +
  geom_line(
    aes(group = mrn),
    color = "grey50",
    alpha = 0.5
  ) +
  scale_x_continuous(
    breaks = 0:2,
    labels = c("Cohort A", "Cohort B", "Cohort C/D"),
    limits = c(-0.5, 2.5)
  ) +
  scale_color_manual(
    values = c(
      "Pre1" = "steelblue", "Pre2" = "steelblue", "Pre3" = "red",
      "Post1" = "orange", "Post2" = "orange", "Post3" = "orange"
    )
    #labels = c("Pre1", "Pre2", "Pre3", "Post1", "Post2", "Post3")
  ) +
  labs(
    x = "",
    y = "Patient",
    color = "Sample Type"
  ) +
  theme_bw() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right"
  )

print(p_swimmers_ordered)

# 9. Save the plot
ggsave(
  p_swimmers_ordered,
  file = file.path(wd$outCurr, "Sample_collection_timeline_ordered.pdf"),
  height = max(10, length(unique(swimmers_data$mrn)) * 0.3),
  width = 8,
  limitsize = FALSE
)
write.csv(swimmers_data, file.path(wd$outCurr, "SwimmersData.csv"))


# 11. Zommed section
p_swimmers_ordered3 <- ggplot(
  swimmers_data %>% filter(!pattern %in% c("A", "B_Pre_Only", "B_Post_Only",
                                           "C_Pre_Only", "C_Post_Only")), 
  aes(x = x_pos, y = y_pos)) +
  geom_vline(
    xintercept = c(0, 1, 2),
    linetype = "dashed",
    color = "grey50",
    alpha = 0.5
  ) +
  geom_point(
    aes(color = txt_stat_ordered),
    size = 3,
    shape = 16
  ) +
  geom_line(
    aes(group = mrn),
    color = "grey50",
    alpha = 0.5
  ) +
  geom_text(
    aes(label = time2txt),
    vjust = -1,
    size = 3
  ) +
  scale_x_continuous(
    breaks = 0:2,
    labels = c("Cohort A", "Cohort B", "Cohort C/D"),
    limits = c(-0.5, 2.5)
  ) +
  scale_color_manual(
    values = c(
      "Pre1" = "steelblue", "Pre2" = "steelblue", "Pre3" = "red",
      "Post1" = "orange", "Post2" = "orange", "Post3" = "orange"
    )
    #labels = c("Pre1", "Pre2", "Pre3", "Post1", "Post2", "Post3")
  ) +
  labs(
    x = "",
    y = "Patient",
    color = "Sample Type"
  ) +
  theme_bw() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right"
  )

ggsave(
  p_swimmers_ordered3,
  file = file.path(wd$outCurr, "Sample_collection_timeline_ordered_noTime_Zommed.pdf"),
  height = 15,
  width = 8,
  limitsize = FALSE
)

# 10. Save the plot without the time2txt text
p_swimmers_ordered <- ggplot(swimmers_data, aes(x = x_pos, y = y_pos)) +
  geom_rect(
    data = rect_data,
    inherit.aes = FALSE,
    aes(xmin = xmin, xmax = xmax, ymin = 0, ymax = max(swimmers_data$y_pos) + 1),
    fill = "grey95",
    alpha = 0.5
  ) +
  geom_vline(
    xintercept = c(0, 1, 2),
    linetype = "dashed",
    color = "grey50",
    alpha = 0.5
  ) +
  geom_point(
    aes(color = txt_stat_ordered),
    size = 3,
    shape = 16
  ) +
  geom_line(
    aes(group = mrn),
    color = "grey50",
    alpha = 0.5
  ) +
  scale_x_continuous(
    breaks = 0:2,
    labels = c("Cohort A", "Cohort B", "Cohort C/D"),
    limits = c(-0.5, 2.5)
  ) +
  scale_color_manual(
    values = c(
      "Pre1" = "steelblue", "Pre2" = "steelblue", "Pre3" = "red",
      "Post1" = "orange", "Post2" = "orange", "Post3" = "orange"
    )
    #labels = c("Pre1", "Pre2", "Pre3", "Post1", "Post2", "Post3")
  ) +
  labs(
    x = "",
    y = "Patient",
    color = "Sample Type"
  ) +
  theme_bw() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right"
  )

print(p_swimmers_ordered)

ggsave(
  p_swimmers_ordered,
  file = file.path(wd$outCurr, "Sample_collection_timeline_ordered_noTime.pdf"),
  height = max(10, length(unique(swimmers_data$mrn)) * 0.3),
  width = 8,
  limitsize = FALSE
)
```


## Clean up 

In some cases, we want to remove samples with 2x Pre or 2x Post. These samples are not helpful for our analysis. 

As there were many Post1 and Post2 in mCRPC. We will retain these.

Lets select the sample to keep

```{r}
mrn_with_2x <- df_meta_f2 %>% filter(txt_stat_ordered %in% c("Pre2", "Post2")) %>% pull(mrn) %>% unique()
# mrn to keep (Post1 and Post2 in c)
mrn_to_keep <- df_meta_f2 %>% filter(pattern %in% c("C_Post1_to_C_Post2")) %>% pull(mrn) %>% unique()

mrn_to_examine <- mrn_with_2x[!mrn_with_2x %in% mrn_to_keep]
```

For these mrns, retain the sample closest to treatment date. 

```{r}
df_tmp <- df_meta_f2 %>% filter(mrn %in% mrn_to_examine)
```

Lets select samples closest to treatment date. If "Pre" select earliest pre- ad "Post" select earliest post-

```{r}
# For each mrn and txt_stat, identify the sample to keep (closest to treatment date)
# - For "Pre", keep the sample with the maximum time2txt <= 0 (i.e., closest before treatment)
# - For "Post", keep the sample with the minimum time2txt >= 0 (i.e., closest after treatment)
# Then, get the rows to EXCLUDE (i.e., not the closest)

df_tmp_keep <- df_tmp %>%
  group_by(mrn, txt_stat) %>%
  mutate(
    keep_flag = case_when(
      txt_stat %in% c("Pre", "Pre1", "Pre2", "Pre3") ~ {
        # If any time2txt <= 0, keep the max of those; else, keep the min overall
        if (any(time2txt <= 0, na.rm = TRUE)) {
          time2txt == max(time2txt[time2txt <= 0], na.rm = TRUE)
        } else {
          time2txt == min(time2txt, na.rm = TRUE)
        }
      },
      txt_stat %in% c("Post", "Post1", "Post2", "Post3") ~ {
        # If any time2txt >= 0, keep the min of those; else, keep the max overall
        if (any(time2txt >= 0, na.rm = TRUE)) {
          time2txt == min(time2txt[time2txt >= 0], na.rm = TRUE)
        } else {
          time2txt == max(time2txt, na.rm = TRUE)
        }
      },
      TRUE ~ TRUE
    )
  ) %>%
  ungroup()

# Rows to EXCLUDE (i.e., not the closest to treatment date)
df_tmp_exclude <- df_tmp_keep %>%
  filter(!keep_flag)
```

Create a a df_meta_f for those we want to retain

```{r}
df_meta_f3 <- df_meta_f %>% filter(!HCI_cID %in% df_tmp_exclude$HCI_cID)
```

## Swimmers v2

Recreate the swimmers plot

```{r}
# 3. Relabel txt_stat as Pre1, Pre2, Post1, etc. by date within each patient/cohort/status
df_meta_f4 <- df_meta_f3 %>%
  group_by(mrn, cohort, txt_stat) %>%
  arrange(date, .by_group = TRUE) %>%
  mutate(
    txt_stat_ordered = paste0(txt_stat, row_number())
  ) %>%
  ungroup()

# 4. Assign pattern to each sample
patient_patterns <- get_patient_pattern(df_meta_f4 %>% mutate(txt_stat = txt_stat_ordered))
df_meta_f4 <- df_meta_f4 %>%
  left_join(patient_patterns %>% select(mrn, pattern, total_samples), by = "mrn")

# dplyr::filter(df_meta_f4, mrn == "6911366") %>% select(mrn, HCI_cID, txt_stat, txt_stat_ordered)
# dplyr::filter(patient_patterns, mrn == "6911366") %>% as.data.frame()

# 5. Order patients by pattern and total_samples
ordered_mrns <- df_meta_f4 %>%
  distinct(mrn, pattern, total_samples) %>%
  arrange(
    factor(pattern, levels = pattern_order),
    desc(total_samples)
  ) %>%
  pull(mrn)

# 6. Prepare swimmers_data with correct offsets and positions
swimmers_data <- df_meta_f4 %>%
  mutate(
    base_pos = case_when(
      cohort == "A" ~ 0,
      cohort == "B" ~ 1,
      cohort == "C" ~ 2
    ),
    # Extract trailing number from txt_stat_ordered, default to 1 if missing
    sample_num = as.numeric(str_extract(txt_stat_ordered, "\\d+$")),
    sample_num = ifelse(is.na(sample_num), 1, sample_num),
    # Offset for multiple samples of the same type
    x_offset = (sample_num - 1) * 0.2,
    # Treatment offset: Pre left, Post right
    treatment_offset = case_when(
      grepl("^Pre", txt_stat_ordered) ~ -0.2,
      grepl("^Post", txt_stat_ordered) ~ 0.2,
      TRUE ~ 0
    ),
    # Final x position, shifted to avoid 1/2 dashed line
    x_pos = base_pos + treatment_offset + x_offset - 0.05,
    # y position based on patient order
    y_pos = match(mrn, ordered_mrns),
    # For labeling
    sample_label = txt_stat_ordered
  )

# 7. Rectangle data for cohort boxes
rect_data <- data.frame(
  cohort = c("A", "B", "C"),
  xmin = c(-0.5, 0.5, 1.5),
  xmax = c(0.5, 1.5, 2.5)
)

write.csv(swimmers_data, file.path(wd$outCurr, "SwimmersData_cleaned.csv"))

# 11. Zommed section
p_swimmers_ordered4 <- ggplot(
  swimmers_data %>% filter(!pattern %in% c("A", "B_Pre_Only", "B_Post_Only",
                                           "C_Pre_Only", "C_Post_Only")), 
  aes(x = x_pos, y = y_pos)) +
  geom_vline(
    xintercept = c(0, 1, 2),
    linetype = "dashed",
    color = "grey50",
    alpha = 0.5
  ) +
  geom_point(
    aes(color = txt_stat_ordered),
    size = 3,
    shape = 16
  ) +
  geom_line(
    aes(group = mrn),
    color = "grey50",
    alpha = 0.5
  ) +
  geom_text(
    aes(label = time2txt),
    vjust = -1,
    size = 3
  ) +
  scale_x_continuous(
    breaks = 0:2,
    labels = c("Cohort A", "Cohort B", "Cohort C/D"),
    limits = c(-0.5, 2.5)
  ) +
  scale_color_manual(
    values = c(
      "Pre1" = "steelblue", "Pre2" = "steelblue", "Pre3" = "red",
      "Post1" = "orange", "Post2" = "orange", "Post3" = "orange"
    )
    #labels = c("Pre1", "Pre2", "Pre3", "Post1", "Post2", "Post3")
  ) +
  labs(
    x = "",
    y = "Patient",
    color = "Sample Type"
  ) +
  theme_bw() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right"
  )

ggsave(
  p_swimmers_ordered4,
  file = file.path(wd$outCurr, "Sample_collection_timeline_ordered_noTime_Zommed_cleaned.pdf"),
  height = 15,
  width = 8,
  limitsize = FALSE
)
```

## Bar plot v2

Make a simple barplot to summarize the data. Two columns per cohort. Number of patients & number of samples. 

```{r}
# Calculate overlap between B and C_D cohorts
overlap_patients <- df_meta_f4 %>%
  filter(cohort %in% c("B", "C")) %>%
  group_by(mrn) %>%
  filter(n_distinct(cohort) > 1) %>%
  pull(mrn) %>%
  unique()

# Create summary data frame
summary_data <- df_meta_f4 %>%
  group_by(cohort) %>%
  summarise(
    n_patients = n_distinct(mrn),
    n_samples = n()
  ) %>%
  pivot_longer(
    cols = c(n_patients, n_samples),
    names_to = "metric",
    values_to = "count"
  )

# Create the barplot
p_bar <- ggplot(summary_data, aes(x = cohort, y = count, fill = metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.7), width = 0.6) +
  # Add overlay for C_D cohort showing overlap (only for patients)
  geom_bar(
    data = filter(summary_data, cohort == "C" & metric == "n_patients"),
    aes(y = length(overlap_patients), fill = "Overlap with B"),
    stat = "identity",
    position = position_dodge(width = 0.7),
    width = 0.6,
    alpha = 0.5
  ) +
  scale_fill_manual(
    values = c(
      "n_patients" = "#faedcd",
      "n_samples" = "grey60",
      "Overlap with B" = "darkred"
    ),
    labels = c("Number of Patients", "Number of Samples", "Overlap with B")
  ) +
  labs(
    x = "Cohort",
    y = "Count",
    fill = "Metric"
  ) +
  theme_bw() +
  theme(
    legend.position = "right",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  geom_text(
    aes(label = count),
    position = position_dodge(width = 0.7),
    vjust = -0.5,
    size = 4
  ) +
  # Add annotation for overlap
  annotate(
    "text",
    x = "C_D",
    y = length(overlap_patients),
    label = paste("Overlap:", length(overlap_patients)),
    vjust = -0.5,
    size = 4,
    color = "darkred"
  )

ggsave(p_bar, file=file.path(wd$outCurr, "Patients_number_bar_clean.pdf"), height = 5, width = 7)
```

## Sample number 

Lets get the sample numbers

```{r}
# Calculate number of Pre and Post samples and patients for Cohort B and C using df_meta_f4

# For Cohort B
n_pre_b_samples <- df_meta_f4 %>% filter(cohort == "B", txt_stat %in% c("Pre", "Pre1", "Pre2", "Pre3")) %>% pull(HCI_cID) %>% unique() %>% length()
n_post_b_samples <- df_meta_f4 %>% filter(cohort == "B", txt_stat %in% c("Post", "Post1", "Post2", "Post3")) %>% pull(HCI_cID) %>% unique() %>% length()
n_pre_b_patients <- df_meta_f4 %>% filter(cohort == "B", txt_stat %in% c("Pre", "Pre1", "Pre2", "Pre3")) %>% pull(mrn) %>% unique() %>% length()
n_post_b_patients <- df_meta_f4 %>% filter(cohort == "B", txt_stat %in% c("Post", "Post1", "Post2", "Post3")) %>% pull(mrn) %>% unique() %>% length()

# For Cohort C
n_pre_c_samples <- df_meta_f4 %>% filter(cohort == "C", txt_stat %in% c("Pre", "Pre1", "Pre2", "Pre3")) %>% pull(HCI_cID) %>% unique() %>% length()
n_post_c_samples <- df_meta_f4 %>% filter(cohort == "C", txt_stat %in% c("Post", "Post1", "Post2", "Post3")) %>% pull(HCI_cID) %>% unique() %>% length()
n_pre_c_patients <- df_meta_f4 %>% filter(cohort == "C", txt_stat %in% c("Pre", "Pre1", "Pre2", "Pre3")) %>% pull(mrn) %>% unique() %>% length()
n_post_c_patients <- df_meta_f4 %>% filter(cohort == "C", txt_stat %in% c("Post", "Post1", "Post2", "Post3")) %>% pull(mrn) %>% unique() %>% length()

cat("B cohort:\n")
cat("  Pre samples:", n_pre_b_samples, "\n")
cat("  Post samples:", n_post_b_samples, "\n")
cat("  Pre patients:", n_pre_b_patients, "\n")
cat("  Post patients:", n_post_b_patients, "\n\n")

cat("C cohort:\n")
cat("  Pre samples:", n_pre_c_samples, "\n")
cat("  Post samples:", n_post_c_samples, "\n")
cat("  Pre patients:", n_pre_c_patients, "\n")
cat("  Post patients:", n_post_c_patients, "\n")
```

# Save objects

```{r}
df_a_final <- df_a
df_b_final <- df_b3
df_c_final <- df_c2
save(
  dat_NPX, dat_NPX2, dat_NPX3, 
  meta_file, df_meta_f2, df_meta_f4, df_id_pro,
  df_a_final, df_b_final, df_c_final,
  file = file.path(wd$outData, "01_Metadata.Rdata"))
```


