---
title: "Initial analysis"
date: "2023-04-12"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

# Background

We have cohort of samples profiled for proteomics, genomics and metylation. We want to create a harmonized clinical file for all these patients.

In regards to proteomics. Samples were profiled ;

1) Psomagen cohort
2) Olink 2023 cohort (Q-13356)
3) Olink 2024 cohort

In addition, some patients were also profiled by genomics (KLK2 SNPs) and methylation.

# Objectives

1. Gather data
2. Clean up clinical data
3. Summary of data

# Pre-processing 

## Loading packages

```{r, message=FALSE, warning=FALSE}
library(here)
library(tidyverse)
library(readxl)   
library(readr)
library(stringr)

library(tidyverse)
library(ggplot2)
library(VennDiagram)
library(ggvenn)
```


## Directories

```{r}
wd <- list()
wd$main <- here()
wd$data <- file.path(wd$main, "data")
wd$manishData <- file.path(wd$data, "raw/data_fromManish")
wd$d2024 <- file.path(wd$data, "updated_2024")
wd$d2024_npx <- file.path(wd$d2024, "NPX_data")
wd$output <- file.path(wd$main, "output")
wd$script <- file.path(wd$main, "scripts")

wd$outData <- file.path(wd$output, "data")
wd$outCurr <- file.path(wd$output, "01_InitialAnalysis")
```


Create directories

```{r}
if (!file.exists(wd$outCurr)) {
  dir.create(wd$outCurr)
} else {
  print("Directory already exists")
}
```

Load functions

```{r}
source(file.path(wd$script, "functions.R"))
```



# Objective 1

**Gather data**

## Psomagen 

There were 2 files provided by Manish, we detail them here and read into R.

1. **E3072_AN00003660_AN00003661_NPX_2022-04-21-columns**

This file is the NPX values from Olink. Samples are listed in the `SampleID` column

```{r}
# Read the files
dat_NPX <- readxl::read_excel(file.path(wd$d2024_npx, "batch_01_E3072_AN00003660_AN00003661_NPX_2022-04-21-columns.xlsx"))
```

2. **Proteomic Project Clinical file 07_23_24_Combined_ID.xlsx**

This contains the clinical files of all Proteomics cohort

```{r}
meta_file <- file.path(file.path(wd$d2024, "clinical_data/Proteomic Project Clinical file 09_10_24_Combined_ID_zaki_edited.xlsx"))
```


### NPX data

Read the NPX data 

**E3072_AN00003660_AN00003661_NPX_2022-04-21-columns**

This file is the NPX values from Olink. 

Get Sample ID (listed in the `SampleID` column)

```{r}
b1_id <- unique(dat_NPX$SampleID)
length(b1_id)
```

There are `length(b1_id)` samples assayed by Olink. This includes "Sample Control" as well, an internal control used by Olink. 

Find the number of samples not including the internal control

```{r}
b1_noCtrl <- b1_id[!grepl("SC", b1_id)]
length(b1_noCtrl)
```

### Clinical data

In the Psomagen cohort, some samples were profiled serially. The excel file contains 2 sheets related the Psomagen cohort, sheets 2 & 3.

Sheet 2 contains only the unique patients IDs per row. It contains all the clinical data, eg - surgery, PSA values, tumor stage, date of death...etc. 


While Sheet 3 have the same number of rows as the NPX data. In sheet 3, the same patient with multiple timepoints is represented in multiple rows. There is a column `sample_id` that links to the NPX `sampleID`. 


```{r}
ps_clin.1 <- read_xlsx(meta_file, sheet = 3)
```

## Olink Q-13356 

There were 2 files provided by Manish, we detail them here and read into R.

1. **Q-13356_Kohli_EXTENDED_NPX_2024-03-11**

This file is the NPX values from Olink. Samples are listed in the `SampleID` column


2. The same clinical file as above

This contains the clinical files of Psomagen cohort and Olink Q-13356 cohort


### NPX data

Read the NPX data. Samples are listed in the `SampleID` column

```{r}
# Read the files
dat_NPX2 <- readr::read_delim(file.path(wd$d2024_npx, "batch_02_Q-13356_Kohli_EXTENDED_NPX_2024-03-11.csv"), delim = ";")

dat_NPX2 <- readr::read_delim(file.path(wd$d2024_npx, "Re_delivery_Intensity_based/Q-13356_Data Delivery/Q-13356_Kohli_Intensity_EXTENDED_NPX_2024-10-30.csv"), delim = ";")
```

Get Sample ID

```{r}
b2_id <- unique(dat_NPX2$SampleID)
length(b2_id)
```

There are `r `length(b2_id)` samples assayed by Olink. This includes "Sample Control" as well, an internal control used by Olink. 

Find the number of samples not including the internal control

```{r}
b2_noCtrl <- b2_id[!grepl("CONTROL_SAMPLE|NEG_CTRL|PLATE_CTRL", b2_id)]
length(b2_noCtrl)
```

### Clinical data

In the this Olink Q-13356 cohort, there are no serial samples. Clinical data is contained in sheet 4 & 5. of the excel files.

Sheets 4 & 5 contains contains all the clinical data, eg - surgery, PSA values, tumor stage, date of death...etc. Sheet 4 is limited to the CRPC cohort and sheet 5 is limited to HSPC cohort. There is a column `Sample ID (validation)` that links to the NPX `sampleID`.


```{r}
q_133_clin.1 <- read_xlsx(meta_file, sheet = 4) %>% 
  # Rename columns
  dplyr::rename(sample_id = 'Sample ID (validation)')
n1 <- length(unique(q_133_clin.1$`HCI number`)) 
n1
```

We repeat reading the clinical data of the HSPC cohort

```{r}
q_133_clin.2 <- read_xlsx(meta_file, sheet = 5) %>% 
  # Rename columns
  dplyr::rename(sample_id = 'Sample ID (validation)')
n2 <- length(unique(q_133_clin.2$`HCI Number`)) 
n2
```

Based on the NPX, we have `r length(b2_noCtrl)` samples. Meanwhile in the clinical file, we have `r n1` in CRPC and `r n2` for HSCP. The total in clinical file is `r n1 + n2`.

There is one less patient in the clinical sheet. 

Clarification was given by Claire 

> From: Claire Hanson <Claire.Hanson@hci.utah.edu>   
> Sent: Thursday, June 20, 2024 9:33 AM.  
To: Zaki Wilmot <zaki.wilmot@hci.utah.edu>; Manish Kohli <Manish.Kohli@hci.utah.edu>; Enos Ampaw <Enos.Ampaw@hci.utah.edu>   
> Subject: Re: Overlapping files
> 
> Hi Zaki, 
> 
> The duplicate sample is 34 and 78 (2021-2165). We used sample ID 34 as one of the bridging samples as well. 
> 
>Thanks, 
Claire 

We will keep this in mind when we process the NPX data


## Olink Q-15806

### NPX data

Read the NPX data. Samples are listed in the `SampleID` column

```{r}
# Read the files
dat_NPX3 <- readr::read_delim(file.path(wd$d2024_npx, "Q-15806_Kohli_NPX_2024-07-29.csv"), delim = ";")

dat_NPX3 <- readr::read_delim(file.path(wd$d2024_npx, "Re_delivery_Intensity_based/Q-15806_Data Delivery/Q-15806_Kohli_EXTENDED_NPX_2024-10-30.csv"), delim = ";")
```

Get Sample ID

```{r}
b3_id <- unique(dat_NPX3$SampleID)
length(b3_id)
```

There are `r `length(b3_id)` samples assayed by Olink. This includes "Sample Control" as well, an internal control used by Olink. 

Find the number of samples not including the internal control. This time internal control is given as "NA" in the SampleID.

```{r}
b3_noCtrl <- b3_id[!is.na(b3_id)]
length(b3_noCtrl)
```

We have 88 samples. 

### Clinical data

Two tab of clinical were provided for Olink Q-15806.

The first files details the Olink sampleID and HCI collection id. We read this first, as this is what is currently required

```{r}
q_158_d <- read_xlsx(meta_file, sheet = 8) %>% 
  # Edit column names
  rename(HCI_cID = 'HCI Number',
         sample_id = 'Sample ID',
         Tx_stage = 'Pre/Post Tx?')
```

## Match protein IDs

Make a table of proteins and OlinkIDs

```{r}
d1 <- dat_NPX %>% select(OlinkID, Assay) %>% distinct() %>% 
  mutate(ID_assay = paste(OlinkID, Assay, sep="_"))
d2 <- dat_NPX2 %>% filter(!str_detect(Assay, "control")) %>% select(OlinkID, Assay) %>% distinct() %>% 
  mutate(ID_assay = paste(OlinkID, Assay, sep="_"))

d_all <- rbind(d1,d2) %>% distinct()


d_all <- d_all %>% 
  mutate(inPsom = if_else(ID_assay %in% d1$ID_assay, "Y", "N"),
         inQ1335 = if_else(ID_assay %in% d2$ID_assay, "Y", "N"))

write.csv(d_all, file.path(wd$outCurr, "Proteins_overlap.csv"))

```

We note there are three proteins with mis-match annotation, lets correct this

```{r}
d_all <- d_all %>% 
  mutate(
    Assay = case_when(
      OlinkID == "OID20125" ~ "NT-proBNP",
      OlinkID == "OID20857" ~ "CERT1",
      OlinkID == "OID21084" ~ "WARS1",
      TRUE ~ Assay))
  
# Create a list of Olink paired with protein ID
df_id_pro <- d_all %>% select(OlinkID, Assay) %>% distinct()

write.csv(df_id_pro, file.path(wd$outCurr, "Olink_assay_table.csv"))
```


# Objective 2

**Clean up clinical data**

We want to combine all data as one df. To make counting and overlapping easier. The unique IDs to merge across these different platforms will be the HCI ID. For the clinical data with mrn & HCI collection ID, we make them into a data frame. 


Matt provided us with an updated cohort information. Lets read it in.

```{r}
df_cohort <- read_xlsx(file.path(wd$d2024, "clinical_data/Cohort_grouping_2024_10_21.xlsx")) %>% 
  select(mrn:txt_stat) %>% 
  rename(Psomagen = Discovery,
         Q_13356 = Project_2,
         Q_15806 = Project_4)
```

## Tally

Lets get a tally of the number of sample in all projects

### Sample IDs

In the NPX files we are given the ID as "sample_ID". Lets link the sample ID of the NPX with the sample ID in the clinical data.


```{r}
# --- Psomagen cohort ---- #
# As all sample ID are numbers. We convert it to numeric. Non-number will give NA
# We stored the Psomagen NPX IDs - b1_noCtrl
d1.1 <- data.frame(
  sample_id_psom = as.numeric(b1_noCtrl)
)
# Extract the HCI collection ID from clinical files
d1.2 <- data.frame(
  HCI_cID = ps_clin.1$`collection_id-hci_id`,
  sample_id_psom = as.numeric(ps_clin.1$sample_id)
)
# Merge the two
d1 <- left_join(d1.1, d1.2)
# Santiy check to ensure all NPX data have clinical data, value needs to be 0
sum(is.na(d1$HCI_cID))


# --- Olink Q-13356 cohort ---- #
# We stored the Q-13356 NPX IDs - b2_noCtrl
d2.1 <- data.frame(
  sample_id_Q13356 = as.numeric(b2_noCtrl)
)
# Extract the HCI collection ID from clinical files
# The clinical file also contained a record of a supposed psomagen ID
d2.2 <- data.frame(
  HCI_cID = c(q_133_clin.1$`HCI number`, q_133_clin.2$`HCI Number`),
  sample_id_Q13356 = as.numeric(c(q_133_clin.1$sample_id, q_133_clin.2$sample_id)),
  sample_id_psom_2 = as.numeric(c(q_133_clin.1$`Sample Id (previous analysis)`, q_133_clin.2$`Sample ID (previous analysis)`))
)
# Merge the two
d2 <- left_join(d2.1, d2.2)
# Santiy check to ensure all NPX data have clinical data, value needs to be 0
sum(is.na(d2$HCI_cID))
```

We noted here that there is one sample missing a clinical ID. We go back to the email from Claire that mentioned the sample "2021-2165" was profiled twice and should have the assigned sample_id : 34 and 78 

```{r}
filter(d2, is.na(HCI_cID))
```

We see sample ID 78 is missing clinical data. So we just exclude sample 78 for now

```{r}
d2 <- d2 %>% 
  filter(!sample_id_Q13356 == 78)
```

Repeat for Q-15806

```{r}
d3 <- q_158_d %>% 
  select(HCI_cID, sample_id) %>% 
  mutate(sample_id = as.numeric(sample_id)) %>% 
  rename(sample_id_Q15806 = sample_id)
```

Finally, combine all sample IDs

```{r}
# Combine all the sample IDs
df_meta_f <- df_cohort %>% 
  left_join(d1) %>% 
  left_join(d2) %>% 
  left_join(d3)

write.csv(df_meta_f, file.path(wd$outCurr, "MetaData_Proteomics.csv"))
```

## Venn overlap

Lets get a Venn diagram of the number of samples in each batch

```{r}
un_a <- df_meta_f %>% filter(Psomagen == "Y") %>% pull(HCI_cID)
un_b <- df_meta_f %>% filter(Q_13356 == "Y") %>% pull(HCI_cID)
un_c <- df_meta_f %>% filter(Q_15806 == "Y") %>% pull(HCI_cID)

l_all <- list(
  Psomagen = un_a,
  Q_13356 = un_b,
  Q_15806 = un_c
)

overlap <- calculate.overlap(
x <- list("Psomagen"=un_a, 
          "Q_13356"=un_b,
          "Q_15806"=un_c))

pdf(file=file.path(wd$outCurr, "Samples_venn_overlap.pdf"), width = 5, height = 5)
ggvenn(
  x, 
  fill_color = pal.study,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)
dev.off()

un_a <- df_meta_f %>% filter(Psomagen == "Y") %>% pull(mrn) %>% unique()
un_b <- df_meta_f %>% filter(Q_13356 == "Y") %>% pull(mrn) %>% unique()
un_c <- df_meta_f %>% filter(Q_15806 == "Y") %>% pull(mrn) %>% unique()

l_all <- list(
  Psomagen = un_a,
  Q_13356 = un_b,
  Q_15806 = un_c
)

overlap <- calculate.overlap(
x <- list("Psomagen"=un_a, 
          "Q_13356"=un_b,
          "Q_15806"=un_c))

pdf(file=file.path(wd$outCurr, "Patient_venn_overlap.pdf"), width = 5, height = 5)
ggvenn(
  x, 
  fill_color = pal.study,
  show_percentage = FALSE,
  stroke_size = 0.5, set_name_size = 4
)
dev.off()
```




## Num samples

```{r}
# Step 1: Summarize the data (count samples for each cohort and txt_stat combination)
summary_df <- df_meta_f %>%
  mutate(txt_stat = gsub("[1-2]", "", txt_stat),
         txt_stat = gsub("post", "Post", txt_stat)) %>% 
  group_by(cohort, txt_stat) 

pr1.1 <- print(paste0("Num of patients in All is ", length(unique(summary_df$mrn))))
pr1.2 <- print(paste0("Num of samples in All is ", length(unique(summary_df$HCI_cID))))

summary_df1 <- summary_df %>% 
  summarise(count = n(), .groups = 'drop') %>% 
  # Create a new column that combines cohort and txt_stat
  mutate(cohort_txt_stat =
           paste(cohort, txt_stat, sep = "_"),
         cohort_txt_stat = factor(cohort_txt_stat, levels=c(
           "A_Pre", "A_Post", "B_Pre", "B_Post", "C_D_Pre", "C_D_Post"
         ))) %>% 
  mutate(Batch = "01_All_cohort")


# Psomagen only
summary_df <- df_meta_f %>%
  filter(Psomagen == "Y") %>% 
  mutate(txt_stat = gsub("[1-2]", "", txt_stat),
         txt_stat = gsub("post", "Post", txt_stat))
pr2.1 <- print(paste0("Num of patients in Discovery is ", length(unique(summary_df$mrn))))
pr2.2 <- print(paste0("Num of samples in Discovery is ", length(unique(summary_df$HCI_cID))))

summary_df2 <- summary_df %>% 
  group_by(cohort, txt_stat) %>%
  summarise(count = n(), .groups = 'drop') %>% 
  # Create a new column that combines cohort and txt_stat
  mutate(cohort_txt_stat =
           paste(cohort, txt_stat, sep = "_"),
         cohort_txt_stat = factor(cohort_txt_stat, levels=c(
           "A_Pre", "A_Post", "B_Pre", "B_Post", "C_D_Pre", "C_D_Post"
         ))) %>% 
  mutate(Batch = "02_Discovery")


# Olinks only
summary_df <- df_meta_f %>%
  filter(!Psomagen == "Y") %>% 
  filter(Q_13356 == "Y" | Q_15806 == "Y") %>% 
  mutate(txt_stat = gsub("[1-2]", "", txt_stat),
         txt_stat = gsub("post", "Post", txt_stat)) %>% 
  group_by(cohort, txt_stat)

pr3.1 <- print(paste0("Num of patients in Validation is ", length(unique(summary_df$mrn))))
pr3.2 <- print(paste0("Num of samples in Validation is ", length(unique(summary_df$HCI_cID))))

summary_df3 <- summary_df %>% 
  summarise(count = n(), .groups = 'drop') %>% 
  # Create a new column that combines cohort and txt_stat
  mutate(cohort_txt_stat =
           paste(cohort, txt_stat, sep = "_"),
         cohort_txt_stat = factor(cohort_txt_stat, levels=c(
           "A_Pre", "A_Post", "B_Pre", "B_Post", "C_D_Pre", "C_D_Post"
         ))) %>% 
  mutate(Batch = "03_Validation")


# Step 1: Summarize the data (count samples for each cohort and txt_stat combination)
summary_df <- df_meta_f %>%
  mutate(txt_stat = gsub("[1-2]", "", txt_stat),
         txt_stat = gsub("post", "Post", txt_stat)) %>% 
  filter(txt_stat == "Pre") %>% 
  group_by(cohort, txt_stat) 

pr4.1 <- print(paste0("Num of patients in All is ", length(unique(summary_df$mrn))))
pr4.2 <- print(paste0("Num of samples in All is ", length(unique(summary_df$HCI_cID))))

summary_df4 <- summary_df %>% 
  summarise(count = n(), .groups = 'drop') %>% 
  # Create a new column that combines cohort and txt_stat
  mutate(cohort_txt_stat =
           paste(cohort, txt_stat, sep = "_"),
         cohort_txt_stat = factor(cohort_txt_stat, levels=c(
           "A_Pre", "A_Post", "B_Pre", "B_Post", "C_D_Pre", "C_D_Post"
         ))) %>% 
  mutate(Batch = "04_All_baseline")



summary_df_all <- rbind(summary_df1, summary_df2, summary_df3)

# Custom colors: you can choose shades inspired by Tableau colors
custom_colors <- c(
  "A_Pre" = "#1f77b4", "A_Post" = "#aec7e8",  # Blue shades
  "B_Pre" = "#ff7f0e", "B_Post" = "#ffbb78",  # Orange shades
  "C_D_Pre" = "#2ca02c", "C_D_Post" = "#98df8a"  # Green shades
)

# Updated plot
p1 <- ggplot(summary_df_all, aes(x = 1, y = Batch, size = count, fill = cohort_txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  # Create circles with black border
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  scale_size_area(max_size = 15) +  # Adjust circle sizes
  scale_fill_manual(values = custom_colors) +  # Set custom colors
  labs(x = "Cohort", y = "", fill = "Cohort and txt_stat", size = "Sample Count") +  # Label x-axis and legend
  theme_bw() +  # Clean background
  theme(legend.position = "right", axis.ticks.y = element_blank(),
        panel.grid = element_blank())
ggsave(p1, file=file.path(wd$outCurr, "Treatment_breakdown.pdf"), height = 5, width = 7)
p1


# Plot without overlaps
p2 <- ggplot(summary_df_all, 
             aes(x = c(
               rep(c(1.2, 0.8, 
                     2.2, 1.8,
                     3.2, 2.8),3)
               ),
                 y = Batch, 
                 size = count, fill = cohort_txt_stat)) +
  geom_point(shape = 21, color = "black") +  # Create circles with black border
  geom_text(aes(label = count), vjust = 2, size = 5) +  # Add text underneath circles
  scale_size_area(max_size = 15) +  # Adjust circle sizes
  scale_fill_manual(values = custom_colors) +  # Set custom colors
  labs(x = "Cohort", y = "", fill = "Cohort and txt_stat", size = "Sample Count") +  # Label x-axis and legend
  theme_bw() +  # Clean background
  theme(legend.position = "right", axis.ticks.y = element_blank(),
        panel.grid = element_blank(),
        scale_y_discrete(expand = expansion(add = c(1, 1)))) +
  annotate("text", x = 1.5, y = 1.2,
           label = pr1.1) +
  annotate("text", x = 1.5, y = 1.4,
           label = pr1.2) +
  annotate("text", x = 1.5, y = 2.2,
           label = pr2.1) +
  annotate("text", x = 1.5, y = 2.4,
           label = pr2.2) +
  annotate("text", x = 1.5, y = 3.2,
           label = pr3.1) +
  annotate("text", x = 1.5, y = 3.4,
           label = pr3.2) +
  NULL
p2

ggsave(p2, file=file.path(wd$outCurr, "Sample_numbers_discovery_validation.pdf"), height = 5, width = 12)
```

## Longtidudinal 

Lets plot the distribution of samples. To see how many are longtiduinal samples. Ie - same mrn, profiled pre- and post- treatment. 

```{r}
# Identify patients groups ;
# Group 1 - mrn that occurs 1x
# Group 2 - mrn that occurs 2x
#   -2B - mrn 2x in cohort B 
#   -2C - mrn 2x in cohort C_D
#   -2D - mrn 1x in cohort B & 1x in cohort C_D
# Group 3 - mrn that occurs 3x
#df_meta_f_ori <- df_meta_f 
df_meta_f <- df_meta_f %>% 
  mutate(txt_stat = case_when(txt_stat == "post" ~ "Post",
                              txt_stat == "Pre2" ~ "Pre",
                              txt_stat == "Post2" ~ "Post",
                              TRUE ~ txt_stat)) 

df_tally <- df_meta_f 

df_tally_tmp <- df_tally %>%
  select(mrn, HCI_cID, cohort) %>% distinct()

mrn_counts <- df_tally_tmp %>%
  group_by(mrn, cohort) %>%
  summarise(count = n(), .groups = 'drop') %>%
  pivot_wider(names_from = cohort, values_from = count, values_fill = 0)

tot_counts <- df_meta_f %>%
  group_by(mrn) %>% 
  summarise(total_observations = n())

mrn_counts <- mrn_counts %>% left_join(tot_counts)



group_1_mrns <- mrn_counts %>% filter(total_observations == 1) %>% pull(mrn)
group_2_mrns <- mrn_counts %>% filter(total_observations == 2)
group_2_cohort_B <- group_2_mrns %>% filter(B == 2) %>% pull(mrn)
group_2_cohort_C <- group_2_mrns %>% filter(C_D == 2) %>% pull(mrn)
group_2_mrns_set2 <- group_2_mrns %>% filter(B == 1 & B == 1) %>% pull(mrn)

# -- Group 2--- 
df_group2 <- df_meta_f %>%
  filter(mrn %in% group_2_cohort_B) %>% 
  select(mrn, HCI_cID, cohort, txt_stat) %>% arrange(mrn, cohort, txt_stat)


# Making a function, to avoid repetition
# Define a function that processes a cohort
process_cohort <- function(df_meta_f, cohort_mrns, prefix, start_group) {
  # Step 1: Filter and arrange
  df_cohort <- df_meta_f %>%
    filter(mrn %in% cohort_mrns) %>%
    select(mrn, HCI_cID, cohort, txt_stat) %>%
    arrange(mrn, cohort, txt_stat)
  
  # Step 2: Create the pattern for each mrn
  df_cohort <- df_cohort %>%
    group_by(mrn) %>%
    arrange(cohort, txt_stat) %>%
    mutate(pattern = paste(cohort, txt_stat, collapse = "-")) %>%
    ungroup()
  
  # Step 3: Assign groups based on unique patterns
  unique_patterns <- df_cohort %>%
    distinct(pattern) %>%
    mutate(group = paste0(prefix, LETTERS[start_group + row_number() - 1]))
  
  # Step 4: Merge group information back
  df_cohort <- df_cohort %>%
    left_join(unique_patterns, by = "pattern")
  
  # Return the dataframe and the last group number used
  df_cohort_tmp <- df_cohort %>% select(mrn, group) %>% distinct()
  last_group <- start_group + nrow(unique_patterns) - 1
  
  list(df_cohort_tmp = df_cohort_tmp, last_group = last_group)
}

# Process Group 2B (group_2_cohort_B)
result_B <- process_cohort(df_meta_f, group_2_cohort_B, "Group 2", 1)

# Process Group 2C starting from the next group after Group 2B
result_C <- process_cohort(df_meta_f, group_2_cohort_C, "Group 2", result_B$last_group + 1)

result_CD <- process_cohort(df_meta_f, group_2_mrns_set2, "Group 2", result_C$last_group + 1)

# Combine the results
df_group2_combined <- bind_rows(result_B$df_cohort_tmp, result_C$df_cohort_tmp, result_CD$df_cohort_tmp)


# ---- Group 3 ---- #
# Step 1: Get unique combinations of mrn, cohort, and txt_stat
group_4_mrns <- mrn_counts %>% filter(total_observations == 3) %>% pull(mrn)
df_group4 <- df_meta_f %>%
  filter(mrn %in% group_4_mrns) %>% 
  select(mrn, HCI_cID, cohort, txt_stat) %>% arrange(mrn, cohort, txt_stat)


# data_labeled <- df_group4 %>%
#   group_by(mrn, txt_stat) %>%
#   mutate(txt_stat = ifelse(row_number() == 1, txt_stat, paste0(txt_stat, row_number()))) %>%
#   ungroup()


# Step 1: Create a unique pattern by combining cohort and txt_stat for each mrn
# This creates a pattern for each mrn's cohort-txt_stat combination
df_group4 <- df_group4 %>%
  group_by(mrn) %>%
  arrange(cohort, txt_stat) %>%  # Ensure consistent order
  mutate(pattern = paste(cohort, txt_stat, collapse = "-")) %>%
  ungroup()

# Step 2: Assign groups based on unique patterns
# We create a lookup table where each unique pattern is assigned a group
unique_patterns <- df_group4 %>%
  distinct(pattern) %>%
  mutate(group = paste0("Group 3", LETTERS[row_number()]))


# Step 3: Merge the group information back into the original data
df_group4 <- df_group4 %>%
  left_join(unique_patterns, by = "pattern")
df_group4_tmp <- df_group4 %>% select(mrn, group) %>% distinct()

dat_group <- data.frame(
  mrn = c(group_1_mrns, 
          df_group2_combined$mrn,
          df_group4_tmp$mrn),
  group = c(
    rep("Group 1", each=length(group_1_mrns)),
    df_group2_combined$group,
    df_group4_tmp$group)
)

data <- df_meta_f %>% 
  #select(mrn, HCI_cID, cohort, txt_stat) %>% distinct() %>% 
  left_join(dat_group)

# Label consequtive pre or post
data <- data %>%
  group_by(mrn, txt_stat) %>%
  mutate(txt_stat = ifelse(row_number() == 1, txt_stat, paste0(txt_stat, row_number()))) %>%
  ungroup() %>% 
  mutate(txt_stat = factor(txt_stat, levels=c("Pre", "Pre2", "Post", "Post2")))

df_pre_post <- data
df_pre_post_tmp <- df_pre_post %>%   
  dplyr::rename(SampleID = sample_id_psom) %>% 
  select(cohort, SampleID, txt_stat) %>% 
  mutate(SampleID = as.character(SampleID)) %>% 
  distinct()

data2 <- data %>% group_by(group, cohort, txt_stat) %>% 
  arrange(group) %>% 
  summarize(count = n()) %>% 
  mutate(group = factor(group, levels = (unique(group))))


ggplot(data2, aes(x=cohort, y=group, size=count, fill=txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL

# Custom colors
# Create a new column that combines cohort and txt_stat
data2 <- data2 %>% 
  mutate(cohort_txt_stat =paste(cohort, txt_stat, sep = "_"),
         cohort_txt_stat = factor(cohort_txt_stat, levels=unique(cohort_txt_stat))) 

# Custom colors: you can choose shades inspired by Tableau colors
custom_colors <- c(
  "A_Pre" = "#1f77b4", "A_Post" = "#aec7e8",  # Blue shades
  "B_Pre" = "#ff7f0e", "B_Post" = "#ffbb78", "B_Post2" = "#ffbb78", # Orange shades
  "C_D_Pre" = "#2ca02c", "C_D_Pre2" = "#2ca02c", 
  "C_D_Post" = "#98df8a",  "C_D_Post2" = "#98df8a" # Green shades
)

ggplot(data2, aes(x=cohort, y=group, size=count, fill=cohort_txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(values = custom_colors) +  # Set custom colors 
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL

p2 <- 
ggplot(data2, aes(x=cohort, y=group, size=count, fill=txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  scale_size_area(max_size = 15) +  # Adjust circle sizes
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(values = c("Pre" = "lightblue", "Pre2" = "lightblue", 
                               "Post" = "orange", "Post2"= "orange")) +  # Set fill colors
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL


ggsave(p2, file=file.path(wd$outCurr, "Treatment_grouping_pattern_updated.pdf"), height = 5, width = 12)

write.csv(data, file.path(wd$outCurr, "Treatment_grouping_pattern_updated.csv"))

df_pre_post_ori <- df_pre_post
```

In the local stage, lets group all together. So the plots are on the same scale. Also add the total number of samples

```{r}
# Sum of A (Pre + Post)
sum_A <- data2 %>%
  filter(cohort == "A") %>%
  summarise(total = sum(count)) %>%
  pull(total)

# Create Group 0
# First, summarize "pre/post" status for each cohort
group_0 <- data2 %>%
  mutate(
    txt_stat_grouped = case_when(
      str_detect(txt_stat, regex("pre", ignore_case = TRUE)) ~ "Pre",
      str_detect(txt_stat, regex("post", ignore_case = TRUE)) ~ "Post",
      TRUE ~ as.character(txt_stat)
    )
  ) %>%
  group_by(cohort, txt_stat_grouped) %>%
  summarise(count = sum(count), .groups = "drop") %>%
  
  # Special step: handle A separately
  mutate(
    count = if_else(cohort == "A",
                    sum(count[cohort == "A"]),
                    count)
  ) %>%
  
  mutate(
    group = "Group 01",
    cohort_txt_stat = paste0(cohort, "_", txt_stat_grouped)
  ) %>%
  select(group, cohort, txt_stat = txt_stat_grouped, count, cohort_txt_stat)



# Bind Group 1 and Group 0 together
df_new <- bind_rows(data2, group_0) %>% ungroup %>% distinct()

# Extend view
df_new <- df_new %>%
  bind_rows(tibble(
    group = "Group 00",
    cohort = "A",
    txt_stat = "Pre",
    count = NA,
    cohort_txt_stat = "A_Pre"
  )) %>% mutate(
    txt_stat = factor(txt_stat, levels=c("Pre", "Pre2", "Post", "Post2")),
    cohort_txt_stat = factor(cohort_txt_stat, 
                             levels=c("A_Pre", "A_Post",
                                      "B_Pre", "B_Post", "B_Post2",
                                      "C_D_Pre", "C_D_Pre2", "C_D_Post", "C_D_Post2"
                                      ))
  )

tmp_width <- 0
p2 <- 
ggplot(df_new, aes(x=cohort_txt_stat, y=group, size=count, fill=cohort_txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=tmp_width)) +  
  scale_size_area(max_size = 15) +  # Adjust circle sizes
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=tmp_width)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(
    values = c("A_Pre" = "lightblue", "A_Pre2" = "lightblue", 
               "B_Pre" = "lightblue", "B_Pre2" = "lightblue", 
               "C_D_Pre" = "lightblue", "C_D_Pre2" = "lightblue", 
               "A_Post" = "orange", "A_Post2"= "orange",
               "B_Post" = "orange", "B_Post2"= "orange",
               "C_D_Post" = "orange", "C_D_Post2"= "orange")
    ) +  # Set fill colors
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=tmp_width)) +  # Add text underneath circlesNULL
  NULL


ggsave(p2, file=file.path(wd$outCurr, "Treatment_grouping_pattern_all.pdf"), height = 5, width = 12)
```





### Discovery

We repeat this for discovery cohort alone

```{r}
df_tally <- df_meta_f %>% filter(Psomagen == "Y")

df_tally_tmp <- df_tally %>%
  select(mrn, HCI_cID, cohort) %>% distinct()

mrn_counts <- df_tally_tmp %>%
  group_by(mrn, cohort) %>%
  summarise(count = n(), .groups = 'drop') %>%
  pivot_wider(names_from = cohort, values_from = count, values_fill = 0)

tot_counts <- df_tally %>%
  group_by(mrn) %>% 
  summarise(total_observations = n())

mrn_counts <- mrn_counts %>% left_join(tot_counts)



group_1_mrns <- mrn_counts %>% filter(total_observations == 1) %>% pull(mrn)
group_2_mrns <- mrn_counts %>% filter(total_observations == 2)
group_2_cohort_B <- group_2_mrns %>% filter(B == 2) %>% pull(mrn)
group_2_cohort_C <- group_2_mrns %>% filter(C_D == 2) %>% pull(mrn)
group_2_mrns_set2 <- group_2_mrns %>% filter(B == 1 & B == 1) %>% pull(mrn)

# -- Group 2--- 
df_group2 <- df_tally %>%
  filter(mrn %in% group_2_cohort_B) %>% 
  select(mrn, HCI_cID, cohort, txt_stat) %>% arrange(mrn, cohort, txt_stat)


# Making a function, to avoid repetition
# Define a function that processes a cohort
process_cohort <- function(df_tally, cohort_mrns, prefix, start_group) {
  # Step 1: Filter and arrange
  df_cohort <- df_tally %>%
    filter(mrn %in% cohort_mrns) %>%
    select(mrn, HCI_cID, cohort, txt_stat) %>%
    arrange(mrn, cohort, txt_stat)
  
  # Step 2: Create the pattern for each mrn
  df_cohort <- df_cohort %>%
    group_by(mrn) %>%
    arrange(cohort, txt_stat) %>%
    mutate(pattern = paste(cohort, txt_stat, collapse = "-")) %>%
    ungroup()
  
  # Step 3: Assign groups based on unique patterns
  unique_patterns <- df_cohort %>%
    distinct(pattern) %>%
    mutate(group = paste0(prefix, LETTERS[start_group + row_number() - 1]))
  
  # Step 4: Merge group information back
  df_cohort <- df_cohort %>%
    left_join(unique_patterns, by = "pattern")
  
  # Return the dataframe and the last group number used
  df_cohort_tmp <- df_cohort %>% select(mrn, group) %>% distinct()
  last_group <- start_group + nrow(unique_patterns) - 1
  
  list(df_cohort_tmp = df_cohort_tmp, last_group = last_group)
}

# Process Group 2B (group_2_cohort_B)
result_B <- process_cohort(df_tally, group_2_cohort_B, "Group 2", 1)

# Process Group 2C starting from the next group after Group 2B
result_C <- process_cohort(df_tally, group_2_cohort_C, "Group 2", result_B$last_group + 1)

result_CD <- process_cohort(df_tally, group_2_mrns_set2, "Group 2", result_C$last_group + 1)

# Combine the results
df_group2_combined <- bind_rows(result_B$df_cohort_tmp, result_C$df_cohort_tmp, result_CD$df_cohort_tmp)


# ---- Group 3 ---- #
# Step 1: Get unique combinations of mrn, cohort, and txt_stat
group_4_mrns <- mrn_counts %>% filter(total_observations == 3) %>% pull(mrn)
df_group4 <- df_tally %>%
  filter(mrn %in% group_4_mrns) %>% 
  select(mrn, HCI_cID, cohort, txt_stat) %>% arrange(mrn, cohort, txt_stat)


# data_labeled <- df_group4 %>%
#   group_by(mrn, txt_stat) %>%
#   mutate(txt_stat = ifelse(row_number() == 1, txt_stat, paste0(txt_stat, row_number()))) %>%
#   ungroup()


# Step 1: Create a unique pattern by combining cohort and txt_stat for each mrn
# This creates a pattern for each mrn's cohort-txt_stat combination
df_group4 <- df_group4 %>%
  group_by(mrn) %>%
  arrange(cohort, txt_stat) %>%  # Ensure consistent order
  mutate(pattern = paste(cohort, txt_stat, collapse = "-")) %>%
  ungroup()

# Step 2: Assign groups based on unique patterns
# We create a lookup table where each unique pattern is assigned a group
unique_patterns <- df_group4 %>%
  distinct(pattern) %>%
  mutate(group = paste0("Group 3", LETTERS[row_number()]))


# Step 3: Merge the group information back into the original data
df_group4 <- df_group4 %>%
  left_join(unique_patterns, by = "pattern")
df_group4_tmp <- df_group4 %>% select(mrn, group) %>% distinct()

dat_group <- data.frame(
  mrn = c(group_1_mrns, 
          df_group2_combined$mrn,
          df_group4_tmp$mrn),
  group = c(
    rep("Group 1", each=length(group_1_mrns)),
    df_group2_combined$group,
    df_group4_tmp$group)
)

data <- df_tally %>% 
  #select(mrn, HCI_cID, cohort, txt_stat) %>% distinct() %>% 
  left_join(dat_group)

# Label consequtive pre or post
data <- data %>%
  group_by(mrn, txt_stat) %>%
  mutate(txt_stat = ifelse(row_number() == 1, txt_stat, paste0(txt_stat, row_number()))) %>%
  ungroup() %>% 
  mutate(txt_stat = factor(txt_stat, levels=c("Pre", "Pre2", "Post", "Post2")))

df_pre_post <- data
df_pre_post_tmp <- df_pre_post %>%   
  dplyr::rename(SampleID = sample_id_psom) %>% 
  select(cohort, SampleID, txt_stat) %>% 
  mutate(SampleID = as.character(SampleID)) %>% 
  distinct()

data2 <- data %>% group_by(group, cohort, txt_stat) %>% 
  arrange(group) %>% 
  summarize(count = n()) %>% 
  mutate(group = factor(group, levels = (unique(group))))


ggplot(data2, aes(x=cohort, y=group, size=count, fill=txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL

# Custom colors
# Create a new column that combines cohort and txt_stat
data2 <- data2 %>% 
  mutate(cohort_txt_stat =paste(cohort, txt_stat, sep = "_"),
         cohort_txt_stat = factor(cohort_txt_stat, levels=unique(cohort_txt_stat))) 

# Custom colors: you can choose shades inspired by Tableau colors
custom_colors <- c(
  "A_Pre" = "#1f77b4", "A_Post" = "#aec7e8",  # Blue shades
  "B_Pre" = "#ff7f0e", "B_Post" = "#ffbb78", "B_Post2" = "#ffbb78", # Orange shades
  "C_D_Pre" = "#2ca02c", "C_D_Pre2" = "#2ca02c", 
  "C_D_Post" = "#98df8a",  "C_D_Post2" = "#98df8a" # Green shades
)

ggplot(data2, aes(x=cohort, y=group, size=count, fill=cohort_txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(values = custom_colors) +  # Set custom colors 
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL

p2 <- 
ggplot(data2, aes(x=cohort, y=group, size=count, fill=txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  scale_size_area(max_size = 15) +  # Adjust circle sizes
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(values = c("Pre" = "lightblue", "Pre2" = "lightblue", 
                               "Post" = "orange", "Post2"= "orange")) +  # Set fill colors
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL


ggsave(p2, file=file.path(wd$outCurr, "Treatment_grouping_pattern_psomagen.pdf"), height = 5, width = 12)

write.csv(data, file.path(wd$outCurr, "Treatment_grouping_pattern_psomagen.csv"))
```


### Independent

Repeat this for the independent cohort alone

We repeat this for discovery cohort alone

```{r}
df_tally <- df_meta_f %>% filter(Psomagen == "N")

df_tally_tmp <- df_tally %>%
  select(mrn, HCI_cID, cohort) %>% distinct()

mrn_counts <- df_tally_tmp %>%
  group_by(mrn, cohort) %>%
  summarise(count = n(), .groups = 'drop') %>%
  pivot_wider(names_from = cohort, values_from = count, values_fill = 0)

tot_counts <- df_tally %>%
  group_by(mrn) %>% 
  summarise(total_observations = n())

mrn_counts <- mrn_counts %>% left_join(tot_counts)



group_1_mrns <- mrn_counts %>% filter(total_observations == 1) %>% pull(mrn)
group_2_mrns <- mrn_counts %>% filter(total_observations == 2)
group_2_cohort_B <- group_2_mrns %>% filter(B == 2) %>% pull(mrn)
group_2_cohort_C <- group_2_mrns %>% filter(C_D == 2) %>% pull(mrn)
group_2_mrns_set2 <- group_2_mrns %>% filter(B == 1 & B == 1) %>% pull(mrn)

# -- Group 2--- 
df_group2 <- df_tally %>%
  filter(mrn %in% group_2_cohort_B) %>% 
  select(mrn, HCI_cID, cohort, txt_stat) %>% arrange(mrn, cohort, txt_stat)


# Making a function, to avoid repetition
# Define a function that processes a cohort
process_cohort <- function(df_tally, cohort_mrns, prefix, start_group) {
  # Step 1: Filter and arrange
  df_cohort <- df_tally %>%
    filter(mrn %in% cohort_mrns) %>%
    select(mrn, HCI_cID, cohort, txt_stat) %>%
    arrange(mrn, cohort, txt_stat)
  
  # Step 2: Create the pattern for each mrn
  df_cohort <- df_cohort %>%
    group_by(mrn) %>%
    arrange(cohort, txt_stat) %>%
    mutate(pattern = paste(cohort, txt_stat, collapse = "-")) %>%
    ungroup()
  
  # Step 3: Assign groups based on unique patterns
  unique_patterns <- df_cohort %>%
    distinct(pattern) %>%
    mutate(group = paste0(prefix, LETTERS[start_group + row_number() - 1]))
  
  # Step 4: Merge group information back
  df_cohort <- df_cohort %>%
    left_join(unique_patterns, by = "pattern")
  
  # Return the dataframe and the last group number used
  df_cohort_tmp <- df_cohort %>% select(mrn, group) %>% distinct()
  last_group <- start_group + nrow(unique_patterns) - 1
  
  list(df_cohort_tmp = df_cohort_tmp, last_group = last_group)
}

# Process Group 2B (group_2_cohort_B)
result_B <- process_cohort(df_tally, group_2_cohort_B, "Group 2", 1)

# Process Group 2C starting from the next group after Group 2B
result_C <- process_cohort(df_tally, group_2_cohort_C, "Group 2", result_B$last_group + 1)

result_CD <- process_cohort(df_tally, group_2_mrns_set2, "Group 2", result_C$last_group + 1)

# Combine the results
df_group2_combined <- bind_rows(result_B$df_cohort_tmp, result_C$df_cohort_tmp, result_CD$df_cohort_tmp)


# ---- Group 3 ---- #
# Step 1: Get unique combinations of mrn, cohort, and txt_stat
group_4_mrns <- mrn_counts %>% filter(total_observations == 3) %>% pull(mrn)
df_group4 <- df_tally %>%
  filter(mrn %in% group_4_mrns) %>% 
  select(mrn, HCI_cID, cohort, txt_stat) %>% arrange(mrn, cohort, txt_stat)


# data_labeled <- df_group4 %>%
#   group_by(mrn, txt_stat) %>%
#   mutate(txt_stat = ifelse(row_number() == 1, txt_stat, paste0(txt_stat, row_number()))) %>%
#   ungroup()


# Step 1: Create a unique pattern by combining cohort and txt_stat for each mrn
# This creates a pattern for each mrn's cohort-txt_stat combination
df_group4 <- df_group4 %>%
  group_by(mrn) %>%
  arrange(cohort, txt_stat) %>%  # Ensure consistent order
  mutate(pattern = paste(cohort, txt_stat, collapse = "-")) %>%
  ungroup()

# Step 2: Assign groups based on unique patterns
# We create a lookup table where each unique pattern is assigned a group
unique_patterns <- df_group4 %>%
  distinct(pattern) %>%
  mutate(group = paste0("Group 3", LETTERS[row_number()]))


# Step 3: Merge the group information back into the original data
df_group4 <- df_group4 %>%
  left_join(unique_patterns, by = "pattern")
df_group4_tmp <- df_group4 %>% select(mrn, group) %>% distinct()

dat_group <- data.frame(
  mrn = c(group_1_mrns, 
          df_group2_combined$mrn,
          df_group4_tmp$mrn),
  group = c(
    rep("Group 1", each=length(group_1_mrns)),
    df_group2_combined$group,
    df_group4_tmp$group)
)

data <- df_tally %>% 
  #select(mrn, HCI_cID, cohort, txt_stat) %>% distinct() %>% 
  left_join(dat_group)

# Label consequtive pre or post
data <- data %>%
  group_by(mrn, txt_stat) %>%
  mutate(txt_stat = ifelse(row_number() == 1, txt_stat, paste0(txt_stat, row_number()))) %>%
  ungroup() %>% 
  mutate(txt_stat = factor(txt_stat, levels=c("Pre", "Pre2", "Post", "Post2")))

df_pre_post <- data
df_pre_post_tmp <- df_pre_post %>%   
  dplyr::rename(SampleID = sample_id_psom) %>% 
  select(cohort, SampleID, txt_stat) %>% 
  mutate(SampleID = as.character(SampleID)) %>% 
  distinct()

data2 <- data %>% group_by(group, cohort, txt_stat) %>% 
  arrange(group) %>% 
  summarize(count = n()) %>% 
  mutate(group = factor(group, levels = (unique(group))))


ggplot(data2, aes(x=cohort, y=group, size=count, fill=txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL

# Custom colors
# Create a new column that combines cohort and txt_stat
data2 <- data2 %>% 
  mutate(cohort_txt_stat =paste(cohort, txt_stat, sep = "_"),
         cohort_txt_stat = factor(cohort_txt_stat, levels=unique(cohort_txt_stat))) 

# Custom colors: you can choose shades inspired by Tableau colors
custom_colors <- c(
  "A_Pre" = "#1f77b4", "A_Post" = "#aec7e8",  # Blue shades
  "B_Pre" = "#ff7f0e", "B_Post" = "#ffbb78", "B_Post2" = "#ffbb78", # Orange shades
  "C_D_Pre" = "#2ca02c", "C_D_Pre2" = "#2ca02c", 
  "C_D_Post" = "#98df8a",  "C_D_Post2" = "#98df8a" # Green shades
)

ggplot(data2, aes(x=cohort, y=group, size=count, fill=cohort_txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(values = custom_colors) +  # Set custom colors 
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL

p2 <- 
ggplot(data2, aes(x=cohort, y=group, size=count, fill=txt_stat)) +
  geom_point(shape = 21, color = "black", position=position_dodge(width=0.5)) +  
  scale_size_area(max_size = 15) +  # Adjust circle sizes
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circles
  theme_bw() +  # Clean background
  scale_fill_manual(values = c("Pre" = "lightblue", "Pre2" = "lightblue", 
                               "Post" = "orange", "Post2"= "orange")) +  # Set fill colors
  theme(legend.position = "right", panel.grid = element_blank()) +
  geom_text(aes(label = count), vjust = 2, size = 5, position=position_dodge(width=0.5)) +  # Add text underneath circlesNULL
  NULL


ggsave(p2, file=file.path(wd$outCurr, "Treatment_grouping_pattern_indpnt.pdf"), height = 5, width = 12)

write.csv(data, file.path(wd$outCurr, "Treatment_grouping_pattern_indpnt.csv"))
```

## Objective 3

Lets summarize the data

```{r}
# Number of cohort B unique patients
df_meta_f %>% filter(cohort == "B") %>% pull(mrn) %>% unique() %>% length()

# Number of cohort C unique patients
df_meta_f %>% filter(cohort == "C_D") %>% pull(mrn) %>% unique() %>% length()

# Number of cohort C samples
df_meta_f %>% filter(cohort == "C_D") %>% nrow()
```

Make a simple barplot to summarize the data. Two columns per cohort. Number of patients & number of samples. 

```{r}
# Calculate overlap between B and C_D cohorts
overlap_patients <- df_meta_f %>%
  filter(cohort %in% c("B", "C_D")) %>%
  group_by(mrn) %>%
  filter(n_distinct(cohort) > 1) %>%
  pull(mrn) %>%
  unique()

# Create summary data frame
summary_data <- df_meta_f %>%
  group_by(cohort) %>%
  summarise(
    n_patients = n_distinct(mrn),
    n_samples = n()
  ) %>%
  pivot_longer(
    cols = c(n_patients, n_samples),
    names_to = "metric",
    values_to = "count"
  )

# Create the barplot
p_bar <- ggplot(summary_data, aes(x = cohort, y = count, fill = metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.7), width = 0.6) +
  # Add overlay for C_D cohort showing overlap (only for patients)
  geom_bar(
    data = filter(summary_data, cohort == "C_D" & metric == "n_patients"),
    aes(y = length(overlap_patients), fill = "Overlap with B"),
    stat = "identity",
    position = position_dodge(width = 0.7),
    width = 0.6,
    alpha = 0.5
  ) +
  scale_fill_manual(
    values = c(
      "n_patients" = "#faedcd",
      "n_samples" = "grey60",
      "Overlap with B" = "darkred"
    ),
    labels = c("Number of Patients", "Number of Samples", "Overlap with B")
  ) +
  labs(
    x = "Cohort",
    y = "Count",
    fill = "Metric"
  ) +
  theme_bw() +
  theme(
    legend.position = "right",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  geom_text(
    aes(label = count),
    position = position_dodge(width = 0.7),
    vjust = -0.5,
    size = 4
  ) +
  # Add annotation for overlap
  annotate(
    "text",
    x = "C_D",
    y = length(overlap_patients),
    label = paste("Overlap:", length(overlap_patients)),
    vjust = -0.5,
    size = 4,
    color = "darkred"
  )

ggsave(p_bar, file=file.path(wd$outCurr, "Patients_number_bar.pdf"), height = 5, width = 7)
```

Analyze serial samples

```{r}
# Identify patients with serial samples
serial_patients <- df_meta_f %>%
  group_by(mrn, cohort) %>%
  summarise(n_samples = n(), .groups = 'drop') %>%
  filter(n_samples > 1) %>%
  pull(mrn)

# Count serial samples per cohort
serial_samples <- df_meta_f %>%
  filter(mrn %in% serial_patients) %>%
  group_by(cohort) %>%
  summarise(
    n_serial_samples = n(),
    n_serial_patients = n_distinct(mrn)
  )

# Create summary data frame for serial samples
summary_serial <- df_meta_f %>%
  group_by(cohort) %>%
  summarise(
    n_patients = n_distinct(mrn),
    n_samples = n()
  ) %>%
  left_join(serial_samples, by = "cohort") %>%
  mutate(n_serial_samples = replace_na(n_serial_samples, 0)) %>%
  pivot_longer(
    cols = c(n_patients, n_samples),
    names_to = "metric",
    values_to = "count"
  )

# Create the barplot with serial samples overlay
p_serial <- ggplot(summary_serial, aes(x = cohort, y = count, fill = metric)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.7), width = 0.6) +
  # Add overlay for serial samples
  geom_bar(
    data = filter(summary_serial, metric == "n_samples"),
    aes(y = n_serial_samples, fill = "Serial Samples"),
    stat = "identity",
    position = position_dodge(width = 0.7),
    width = 0.6,
    alpha = 0.5
  ) +
  scale_fill_manual(
    values = c(
      "n_patients" = "#faedcd",
      "n_samples" = "grey60",
      "Serial Samples" = "darkgreen"
    ),
    labels = c("Number of Patients", "Number of Samples", "Serial Samples")
  ) +
  labs(
    x = "Cohort",
    y = "Count",
    fill = "Metric"
  ) +
  theme_bw() +
  theme(
    legend.position = "right",
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  geom_text(
    aes(label = count),
    position = position_dodge(width = 0.7),
    vjust = -0.5,
    size = 4
  ) +
  # Add annotation for serial samples
  geom_text(
    data = filter(summary_serial, metric == "n_samples"),
    aes(y = n_serial_samples, label = paste("Serial:", n_serial_samples)),
    position = position_dodge(width = 0.7),
    vjust = -0.5,
    size = 4,
    color = "darkgreen"
  )

# Print summary of serial samples
cat("Summary of serial samples:\n")
print(serial_samples)

# Save the plot
ggsave(p_serial, file=file.path(wd$outCurr, "Serial_samples_breakdown.pdf"), height = 5, width = 7)
```

# Create swimmers plot for sample collection timeline
```{r}
# Function to determine patient pattern
get_patient_pattern <- function(data) {
  data %>%
    group_by(mrn) %>%
    summarise(
      has_a = any(cohort == "A"),  # Simplified A cohort check
      has_b_pre = any(cohort == "B" & txt_stat == "Pre"),
      has_b_post = any(cohort == "B" & txt_stat == "Post"),
      has_b_post2 = any(cohort == "B" & txt_stat == "Post2"),
      has_c_pre = any(cohort == "C_D" & txt_stat == "Pre"),
      has_c_post = any(cohort == "C_D" & txt_stat == "Post"),
      has_c_post2 = any(cohort == "C_D" & txt_stat == "Post2"),
      n_b_samples = sum(cohort == "B"),
      n_c_samples = sum(cohort == "C_D"),
      .groups = "drop"
    ) %>%
    mutate(
      # First identify serial samples based on number of samples
      is_b_serial = n_b_samples > 1,
      is_c_serial = n_c_samples > 1,
      # Then determine the pattern
      pattern = case_when(
        # Cohort A (all treated as one group)
        has_a & !has_b_pre & !has_b_post & !has_c_pre & !has_c_post ~ "A",
        # Non-serial Cohort B patterns
        has_b_pre & !has_b_post & !has_c_pre & !has_c_post & !is_b_serial ~ "B_Pre_Only",
        !has_b_pre & has_b_post & !has_c_pre & !has_c_post & !is_b_serial ~ "B_Post_Only",
        # Non-serial Cohort C patterns
        !has_b_pre & !has_b_post & has_c_pre & !has_c_post & !is_c_serial ~ "C_Pre_Only",
        !has_b_pre & !has_b_post & !has_c_pre & has_c_post & !is_c_serial ~ "C_Post_Only",
        # Serial patterns - Cohort B
        is_b_serial & has_b_pre & has_b_post & !has_b_post2 & !has_c_pre & !has_c_post ~ "B_Serial_PrePost",
        is_b_serial & has_b_pre & has_b_post & has_b_post2 & !has_c_pre & !has_c_post ~ "B_Serial_PrePostPost2",
        # Serial patterns - Cohort C
        !has_b_pre & !has_b_post & is_c_serial & has_c_pre & has_c_post & !has_c_post2 ~ "C_Serial_PrePost",
        !has_b_pre & !has_b_post & is_c_serial & has_c_pre & has_c_post & has_c_post2 ~ "C_Serial_PrePostPost2",
        # Mixed patterns
        (has_b_pre | has_b_post) & (has_c_pre | has_c_post) ~ "Mixed",
        TRUE ~ "Other"
      ),
      # Order within pattern by number of samples
      total_samples = n_b_samples + n_c_samples
    )
}

# Get patient patterns
df_meta_f2 <- df_meta_f %>% mutate(txt_stat = case_when(cohort == "A" & txt_stat == "Post" ~ "Pre",
                                                        TRUE ~ txt_stat))

# Diagnostic: Check unique txt_stat values
print("Unique txt_stat values:")
print(unique(df_meta_f2$txt_stat))

# Diagnostic: Check samples with Post2
print("Samples with Post2:")
print(df_meta_f2 %>% filter(txt_stat == "Post2") %>% select(mrn, cohort, txt_stat))

patient_patterns <- get_patient_pattern(df_meta_f2)

# Diagnostic: Check patterns with Post2
print("Patterns with Post2:")
print(patient_patterns %>% filter(has_b_post2 | has_c_post2))

# Define pattern order
pattern_order <- c(
  "A",
  "B_Pre_Only", "B_Post_Only",
  "C_Pre_Only", "C_Post_Only",
  "B_Serial_PrePost", "B_Serial_PrePostPost2",
  "C_Serial_PrePost", "C_Serial_PrePostPost2",
  "Mixed", "Other"
)

# Create ordered factor for mrn
ordered_mrns <- patient_patterns %>%
  arrange(
    factor(pattern, levels = pattern_order),
    desc(total_samples)
  ) %>%
  pull(mrn)

# Print summary of patterns
pattern_summary <- patient_patterns %>%
  group_by(pattern) %>%
  summarise(
    n_patients = n(),
    .groups = "drop"
  ) %>%
  arrange(factor(pattern, levels = pattern_order))

print("Summary of patient patterns:")
print(pattern_summary)

# Create swimmers plot with ordered patients
swimmers_data <- df_meta_f2 %>%
  # Create a unique identifier for each sample within patient and treatment status
  group_by(mrn, cohort, txt_stat) %>%
  mutate(
    sample_order = row_number(),
    sample_label = case_when(
      sample_order == 1 ~ txt_stat,
      TRUE ~ paste0(txt_stat, sample_order)
    ),
    # Add horizontal offset for multiple samples
    x_offset = (sample_order - 1) * 0.2
  ) %>%
  ungroup() %>%
  # Create x-axis positions for cohorts
  mutate(
    # Base position for each cohort
    base_pos = case_when(
      cohort == "A" ~ 0,
      cohort == "B" ~ 1,
      cohort == "C_D" ~ 2
    ),
    # Add treatment status offset (pre to left, post to right)
    treatment_offset = case_when(
      txt_stat == "Pre" ~ -0.2,
      txt_stat == "Pre2" ~ -0.2,
      txt_stat == "Post" ~ 0.2,
      txt_stat == "Post2" ~ 0.2,
      TRUE ~ 0
    ),
    # Combine base position, treatment offset, and sample order offset
    x_pos = base_pos + treatment_offset + x_offset,
    # Create y-axis positions based on ordered mrns
    y_pos = match(mrn, ordered_mrns)
  )

# Create rectangle data for cohort boxes
rect_data <- data.frame(
  cohort = c("A", "B", "C_D"),
  xmin = c(-0.5, 0.5, 1.5),
  xmax = c(0.5, 1.5, 2.5)
)

# Create the swimmers plot
p_swimmers_ordered <- ggplot(swimmers_data, aes(x = x_pos, y = y_pos)) +
  # Add cohort boxes
  geom_rect(
    data = rect_data,
    inherit.aes = FALSE,
    aes(xmin = xmin, xmax = xmax, ymin = 0, ymax = max(swimmers_data$y_pos) + 1),
    fill = "grey95",
    alpha = 0.5
  ) +
  # Add vertical lines for cohort centers
  geom_vline(
    xintercept = c(0, 1, 2),
    linetype = "dashed",
    color = "grey50",
    alpha = 0.5
  ) +
  # Add points for each sample
  geom_point(
    aes(color = txt_stat),
    size = 3,
    shape = 16
  ) +
  # Add sample labels
  geom_text(
    aes(label = sample_label),
    hjust = -0.5,
    size = 3
  ) +
  # Add connecting lines between samples
  geom_line(
    aes(group = mrn),
    color = "grey50",
    alpha = 0.5
  ) +
  # Customize the plot
  scale_x_continuous(
    breaks = 0:2,
    labels = c("Cohort A", "Cohort B", "Cohort C/D"),
    limits = c(-0.5, 2.5)
  ) +
  scale_color_manual(
    values = c(
      "Pre" = "steelblue",
      "Pre2" = "steelblue",
      "Post" = "orange",
      "Post2" = "orange"
    ),
    labels = c("Pre-treatment", "Pre-treatment 2", "Post-treatment", "Post-treatment 2")
  ) +
  labs(
    x = "",
    y = "Patient",
    color = "Sample Type"
  ) +
  theme_bw() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right"
  )

p_swimmers_ordered

# # Save the plot
# ggsave(
#   p_swimmers_ordered,
#   file = file.path(wd$outCurr, "Sample_collection_timeline_ordered.pdf"),
#   height = max(10, length(unique(swimmers_data$mrn)) * 0.3),
#   width = 8
# )
```

# Cluster and order patients based on sample patterns
```{r}
# Function to determine patient pattern
get_patient_pattern <- function(data) {
  data %>%
    group_by(mrn) %>%
    summarise(
      has_a = any(cohort == "A"),  # Simplified A cohort check
      has_b_pre = any(cohort == "B" & txt_stat == "Pre"),
      has_b_post = any(cohort == "B" & txt_stat == "Post"),
      has_b_post2 = any(cohort == "B" & txt_stat == "Post2"),
      has_c_pre = any(cohort == "C_D" & txt_stat == "Pre"),
      has_c_post = any(cohort == "C_D" & txt_stat == "Post"),
      has_c_post2 = any(cohort == "C_D" & txt_stat == "Post2"),
      n_b_samples = sum(cohort == "B"),
      n_c_samples = sum(cohort == "C_D"),
      .groups = "drop"
    ) %>%
    mutate(
      # First identify serial samples based on number of samples
      is_b_serial = n_b_samples > 1,
      is_c_serial = n_c_samples > 1,
      # Then determine the pattern
      pattern = case_when(
        # Cohort A (all treated as one group)
        has_a & !has_b_pre & !has_b_post & !has_c_pre & !has_c_post ~ "A",
        # Non-serial Cohort B patterns
        has_b_pre & !has_b_post & !has_c_pre & !has_c_post & !is_b_serial ~ "B_Pre_Only",
        !has_b_pre & has_b_post & !has_c_pre & !has_c_post & !is_b_serial ~ "B_Post_Only",
        # Non-serial Cohort C patterns
        !has_b_pre & !has_b_post & has_c_pre & !has_c_post & !is_c_serial ~ "C_Pre_Only",
        !has_b_pre & !has_b_post & !has_c_pre & has_c_post & !is_c_serial ~ "C_Post_Only",
        # Serial patterns - Cohort B
        is_b_serial & has_b_pre & has_b_post & !has_b_post2 & !has_c_pre & !has_c_post ~ "B_Serial_PrePost",
        is_b_serial & has_b_pre & has_b_post & has_b_post2 & !has_c_pre & !has_c_post ~ "B_Serial_PrePostPost2",
        # Serial patterns - Cohort C
        !has_b_pre & !has_b_post & is_c_serial & has_c_pre & has_c_post & !has_c_post2 ~ "C_Serial_PrePost",
        !has_b_pre & !has_b_post & is_c_serial & has_c_pre & has_c_post & has_c_post2 ~ "C_Serial_PrePostPost2",
        # Mixed patterns
        (has_b_pre | has_b_post) & (has_c_pre | has_c_post) ~ "Mixed",
        TRUE ~ "Other"
      ),
      # Order within pattern by number of samples
      total_samples = n_b_samples + n_c_samples
    )
}

# Get patient patterns
df_meta_f2 <- df_meta_f %>% mutate(txt_stat = case_when(cohort == "A" & txt_stat == "Post" ~ "Pre",
                                                        TRUE ~ txt_stat))

patient_patterns <- get_patient_pattern(df_meta_f2)

# Define pattern order
pattern_order <- c(
  "A",
  "B_Pre_Only", "B_Post_Only",
  "C_Pre_Only", "C_Post_Only",
  "B_Serial_PrePost", "B_Serial_PrePostPost2",
  "C_Serial_PrePost", "C_Serial_PrePostPost2",
  "Mixed", "Other"
)

# Create ordered factor for mrn
ordered_mrns <- patient_patterns %>%
  arrange(
    factor(pattern, levels = pattern_order),
    desc(total_samples)
  ) %>%
  pull(mrn)

# Print summary of patterns
pattern_summary <- patient_patterns %>%
  group_by(pattern) %>%
  summarise(
    n_patients = n(),
    .groups = "drop"
  ) %>%
  arrange(factor(pattern, levels = pattern_order))

print("Summary of patient patterns:")
print(pattern_summary)

# Create swimmers plot with ordered patients
swimmers_data <- df_meta_f2 %>%
  # Create a unique identifier for each sample within patient and treatment status
  group_by(mrn, cohort, txt_stat) %>%
  mutate(
    sample_order = row_number(),
    sample_label = case_when(
      sample_order == 1 ~ txt_stat,
      TRUE ~ paste0(txt_stat, sample_order)
    ),
    # Add horizontal offset for multiple samples
    x_offset = (sample_order - 1) * 0.2
  ) %>%
  ungroup() %>%
  # Add a fake Pre3 row for the first patient with Pre2
  bind_rows(
    filter(., cohort == "C_D" & txt_stat == "Pre") %>%
      slice(1) %>%
      mutate(
        txt_stat = "Pre3",
        sample_label = "Pre3",
        x_offset = 0.4  # Position it further left
      )
  ) %>%
  # Create x-axis positions for cohorts
  mutate(
    # Base position for each cohort
    base_pos = case_when(
      cohort == "A" ~ 0,
      cohort == "B" ~ 1,
      cohort == "C_D" ~ 2
    ),
    # Add treatment status offset (pre to left, post to right)
    treatment_offset = case_when(
      txt_stat == "Pre" ~ -0.2,
      txt_stat == "Pre2" ~ -0.2,
      txt_stat == "Pre3" ~ -0.2,
      txt_stat == "Post" ~ 0.2,
      txt_stat == "Post2" ~ 0.2,
      TRUE ~ 0
    ),
    # Combine base position, treatment offset, and sample order offset
    x_pos = base_pos + treatment_offset + x_offset,
    # Create y-axis positions based on ordered mrns
    y_pos = match(mrn, ordered_mrns)
  )

# Create rectangle data for cohort boxes
rect_data <- data.frame(
  cohort = c("A", "B", "C_D"),
  xmin = c(-0.5, 0.5, 1.5),
  xmax = c(0.5, 1.5, 2.5)
)

# Create the swimmers plot
p_swimmers_ordered <- ggplot(swimmers_data, aes(x = x_pos, y = y_pos)) +
  # Add cohort boxes
  geom_rect(
    data = rect_data,
    inherit.aes = FALSE,
    aes(xmin = xmin, xmax = xmax, ymin = 0, ymax = max(swimmers_data$y_pos) + 1),
    fill = "grey95",
    alpha = 0.5
  ) +
  # Add vertical lines for cohort centers
  geom_vline(
    xintercept = c(0, 1, 2),
    linetype = "dashed",
    color = "grey50",
    alpha = 0.5
  ) +
  # Add points for each sample
  geom_point(
    aes(color = txt_stat),
    size = 3,
    shape = 16
  ) +
  # Add sample labels
  geom_text(
    aes(label = sample_label),
    hjust = -0.5,
    size = 3
  ) +
  # Add connecting lines between samples
  geom_line(
    aes(group = mrn),
    color = "grey50",
    alpha = 0.5
  ) +
  # Customize the plot
  scale_x_continuous(
    breaks = 0:2,
    labels = c("Cohort A", "Cohort B", "Cohort C/D"),
    limits = c(-0.5, 2.5)
  ) +
  scale_color_manual(
    values = c(
      "Pre" = "steelblue",
      "Pre2" = "steelblue",
      "Pre3" = "red",
      "Post" = "orange",
      "Post2" = "orange"
    ),
    labels = c("Pre-treatment", "Pre-treatment 2", "Pre-treatment 3", "Post-treatment", "Post-treatment 2")
  ) +
  labs(
    x = "",
    y = "Patient",
    color = "Sample Type"
  ) +
  theme_bw() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "right"
  )

p_swimmers_ordered

# # Save the plot
# ggsave(
#   p_swimmers_ordered,
#   file = file.path(wd$outCurr, "Sample_collection_timeline_ordered.pdf"),
#   height = max(10, length(unique(swimmers_data$mrn)) * 0.3),
#   width = 8
# )
```

# Save objects

```{r}
save(
  dat_NPX, dat_NPX2, dat_NPX3, 
  meta_file, df_meta_f, df_id_pro, df_pre_post_ori,
  file = file.path(wd$outData, "01_Metadata.Rdata"))
```

Adding the dates

```{r}
# First, clean up the dates in dd2
dd2 <- dd2 %>%
  # Remove any rows where both HCI_cID and date are NA
  filter(!(is.na(HCI_cID) & is.na(date))) %>%
  # Convert dates to Date format
  mutate(date = as.Date(date))

# Join with df_meta_f2 and create txt_stat2
df_meta_f2 <- df_meta_f2 %>%
  # Join with dd2 to get dates
  left_join(dd2, by = "HCI_cID") %>%
  # Group by mrn to order samples by date
  group_by(mrn) %>%
  # Create txt_stat2 based on date ordering
  mutate(
    txt_stat2 = case_when(
      # For cohort A, keep as is
      cohort == "A" ~ txt_stat,
      # For other cohorts, label based on date ordering
      TRUE ~ case_when(
        # First sample by date is Pre
        date == min(date, na.rm = TRUE) ~ "Pre",
        # Second sample by date is Pre2
        date == sort(date, na.last = TRUE)[2] ~ "Pre2",
        # Third sample by date is Post
        date == sort(date, na.last = TRUE)[3] ~ "Post",
        # Fourth sample by date is Post2
        date == sort(date, na.last = TRUE)[4] ~ "Post2",
        # If no date available, keep original txt_stat
        is.na(date) ~ txt_stat,
        # Default case
        TRUE ~ txt_stat
      )
    )
  ) %>%
  ungroup()

# Print summary of the changes
print("Summary of txt_stat vs txt_stat2:")
print(table(df_meta_f2$txt_stat, df_meta_f2$txt_stat2, useNA = "ifany"))

# Print samples where txt_stat and txt_stat2 differ
print("Samples where txt_stat and txt_stat2 differ:")
df_meta_f2 %>%
  filter(txt_stat != txt_stat2) %>%
  select(mrn, HCI_cID, cohort, txt_stat, txt_stat2, date) %>%
  arrange(mrn, date) %>%
  print(n = Inf)
```
